################################################################################
Смарт-контракты
################################################################################
.. contents::
  :local:
  :depth: 2

Смарт-контракт (далее просто “контракт”) - это базовый элемент приложений, с помощью которого реализуется выполнение единичного действия (обычно записи в таблицу базы данных), инициированного в интерфейсе пользователем или другим контрактом. Все операции с данными в приложениях оформляются в виде системы контрактов, взаимодействующих через таблицы базы данных или путем вызова друг с друга в теле контракта.

Контракты пишутся на оригинальном (написаном разработчиками платформы) тьюринг-полном скриптовом языке Simvolio с компиляцией в байт-код. Язык содержит необходимый набор функций, операторов и конструкций  для реализации алгоритмов обработки данных и операций со значениями.

Контракты могут редактироваться  (если при его создании эта возможность не была запрещена указанием ``false`` в правах доступа к редактированию контракта). Операции с данными блокчейна выполняет актуальная (последняя по времени) версия контракта. Вся история изменений контрактов сохраняется в блокчейне и доступна в программном клиенте.

********************************************************************************
Структура контракта
********************************************************************************
Контракт определяется ключевым словом contract, после которого указывается имя контракта. Тело контракта заключается в фигурные скобки. Контракт состоит из трех секций: 

1. **data** - используется для описания входящих данных (имена переменных и их типы),
2. **conditions** - реализует проверку входных данных на корректность,
3. **action** - содержит описание действия контракта. 

Структура контракта:

.. code:: js

  contract MyContract {
      data {
          FromId int
          ToId   int
          Amount money
      }
      func conditions {
          ...
      }
      func action {
      }
  }


Cекция data
===========

Входные данные контракта, а так же параметры формы для приема этих данных описываются в секции ``data``. 
Данные перечисляются построчно: сначала указывается имя переменной (передаются только переменные, а не массивы), затем тип и опционально через пробел в двойных кавычках параметры для построения формы интерфейса:

* *optional* - элемент формы без обязательного заполнения.

.. code:: js

  contract my {
    data {
        Name string 
        RequestId int
        Photo file "optional"
        Amount money
        Private bytes
    }
    ...
  }
  
Секция conditions
=================

в секции реализуется проверка входных данных с выводом сообщений об ошибках с помощью команд: ``error``, ``warning``, ``info``. Все эти команды генерируют ошибку, останавливающую работу контракта, но выводят в интерфейсе различные сообщения: *критическая ошибка*, *предупреждение*, и *информативная ошибка*. Например, 

.. code:: js

  if fuel == 0 {
        error "fuel cannot be zero!"
  }
  if money < limit {
        warning Sprintf("You don't have enough money: %v < %v", money, limit)
  }
  if idexist > 0 {
        info "You have been already registered"
  }

Секция action
=============

Секция action содержит основной программный код контракта выполняющий получение дополнительных данных и запись результата в таблицы базы данных. Например,

.. code:: js

	action {
		DBUpdate("keys", $key_id, {"-amount": $amount})
		DBUpdate("keys", $recipient, {"+amount": $amount,pub: $Pub})
	}

Кроме секции action контракт может содержать функцию **price**. Эта функция нужна для установления дополнительной стоимости в единицах топлива при выполнении контракта. Она может возвращать как число типа *int*, так и типа *money*. Возвращенное значение из функции price будет добавлено к стоимости выполнения контракта и умножено на коэффициент **fuel_rate**.

.. code:: js
	
	contract MyContract {
		action {
         	     DBUpdate("keys", $key_id, {"-amount": $amount})
	             DBUpdate("keys", $recipient, {"+amount": $amount,pub: $Pub})
		}
		func price int {
		     return 10000
		}
	}

Переменные в контракте
======================

Входные данные контракта, описанные в секции data,  передаются в другие секции через переменные с именами данных и с символом  ``$`` перед ними. Возможно определить и дополнительные переменные со знаком ``$``, которые будут глобальными в рамках выполнения контракта, включая вложенные контракты. 

В контракте доступны и предопределенные переменные, содержащие данные о транзакции, из которой был вызван данный контракт.

* ``$time`` - время транзакции int,
* ``$ecosystem_id`` - идентификатор экосистемы int,
* ``$block`` - номер блока, в который запечатана транзакция int,
* ``$key_id`` - адрес кошелька подписавшего транзакцию, если контракт вне экосистемы с ``ecosystem_id == 0``,
* ``$block_key_id`` - адрес ноды, сформировавшей блок, в который входит транзакция,
* ``$block_time`` - время формирования блока, который содержит транзакцию с текущим контрактом.
* ``$original_contract`` - имя контракта, который был изначально вызван при обработке транзакции. Если эта переменная равна пустой строке, то значит контракт вызван при проверке какого-то условия. Чтобы проверить, вызвался ли данный контракт другим контрактом или напрямую из транзакции, следует сравнить **$original_contract** и **$this_contract**. Если они равны, то значит контракт был вызван из транзакции.
* ``$this_contract`` - имя текущего выполняемого контракта. 
* ``$guest_key`` - идентификатор гостевого кошелька.
* ``$stack`` - стэк вызовов контрактов. Имеет тип *array* и содержит строки с именами вызванных контрактов. Нулевой элемент массива - это текущий выполняемый контракт, последний элемент массива - это имя оригинального контракта вызванного при обработке транзакции.

Предопределенные переменные доступны не только в контрактах, но и в полях Permissions, в которых указываются условия доступа к элементам приложений (таблицам, контрактам, страницам и пр.) для составления логических выражений. При этом переменные имеющие отношения к формированию блока (``$time``, ``$block`` и др.) имеют нулевое значение.

Предопределенная переменная ``$result`` используется при необходимости возвратить значение из вложенного контракта.

.. code:: js

  contract my {
    data {
        Name string 
        Amount money
    }
    func conditions {
        if $Amount <= 0 {
           error "Amount cannot be 0"
        }
        $ownerId = 1232
    }
    func action {
        var amount money
	amount = $Amount - 10
        DBUpdate("mytable", $ownerId, {name: $Name,amount: amount})
        DBUpdate("mytable2", $citizen, {amount: 10})
    }
  }
  
********************************************************************************
Вложенные контракты
********************************************************************************

В секциях *conditions* и *action* контракта может быть вызван другой контракт с передачей ему данных из текущего контракта.  Вызов вложенного контракта возможен как непосредственно, с указанием параметров в скобках после его имени (``NameContract(Params)``), так и с помощью функции *CallContract*, для которой имя контракта передается через строковую переменную.

********************************************************************************
Загрузка файлов
********************************************************************************
Для загрузки файлов из ``multipart/form-data`` форм, требуется использовать поля контрактов с типом ``file``. Пример:

.. code:: js

    contract Upload {
        data {
            File file
        }
        ...
    }

Для загрузки и хранения файлов предусмотрен системный контрак `UploadBinary`.
Для получения ссылки на скачивание файла из шаблонизатора, предусмотрена функция шаблонизатора `Binary`.

********************************************************************************
Редактор контрактов
********************************************************************************
Контракты создаются и редактируются в специальном редакторе программного клиента Molis. При создании нового контракта в него уже вписана типовая структура с тремя секциями ``data, conditions, action``.  Редактор контрактов обеспечивает:

- написание кода контрактов (с подсветкой ключевых слов языка Simvolio),
- форматирование кода контракта,
- привязку контракта к виртуальному аккаунту, с которого будет происходить оплата его работы,
- задание прав на редактирование контракта,
- просмотр истории изменения контрактов с возможностью восстановления прежних версий.

********************************************************************************
Язык написания контрактов Simvolio
********************************************************************************

Язык написания контрактов Simvolio обеспечивает:

- объявление переменных с различными типами значений, а также простых и ассоциативных массивов: ``var, array, map``,
- использование условной конструкции ``if`` и конструкции цикла ``while``,
- получение значений из базы данных и запись значений в базу данных ``DBFind, DBInsert, DBUpdate``,
- работу с контрактами,
- преобразование значений переменных,
- операции со строковыми значениями.

Базовые элементы и конструкции языка
====================================

Типы значений и переменные 
--------------------------

Переменные языка объявляются с указанием типа значения. В очевидных случаях применяется автоматическое преобразование типов. Используются следующие типы значений:

* ``bool`` - булевый, принимает значения true или false;
* ``bytes`` - последовательность байтов;
* ``int`` - 64-разрядное целое число;
* ``array`` - массив значений с произвольными типами;
* ``map`` - ассоциативный массив значений с произвольными типами со строковыми ключами;
* ``money`` - целое число типа big integer; значения хранятся в базе данных  без десятичных точек, которые вставляется при выводе в интерфейсе в соответствии с настройками валюты;
* ``float`` - 64-разрядное число с плавающей точкой;
* ``string`` - строка; указываются в двойных или обратных кавычках - "This is a line" или `This is a line`;
* ``file`` - ассоциативный массив с определенным набором ключей и значений:
** ``Name`` - название файла, тип string
** ``MimeType`` - mime-тип файла, тип string
** ``Body`` - содержимое файла, тип bytes

Все идентификаторы - имена переменных, функций, контрактов и пр. - регистрозависимы (MyFunc и myFunc - это разные имена). 

Переменные объявляются с помощью ключевого слова **var**, после которого указывается имя или имена переменных и их тип. Переменные определяются и действуют внутри фигурных скобок. При описании переменных им автоматически присваивается значение по умолчанию: для типа *bool* это *false*, для всех числовых типов - нулевые значения, для строк - пустая строка. Примеры объявления переменных: 

.. code:: js

  func myfunc( val int) int {
      var mystr1 mystr2 string, mypar int
      var checked bool
      ...
      if checked {
           var temp int
           ...
      }
  }

Массивы
-------

Язык поддерживает два типа массивов: 

* ``array`` - простой массив с числовым индексом, начинающимся с 0; 
* ``map`` - ассоциативный массив со строковыми ключами.

Присваивание и получение элементов осуществляется указанием индекса в квадратных скобках.

.. code:: js

    var myarr array
    var mymap map
    var s string
    
    myarr[0] = 100
    myarr[1] = "This is a line"
    mymap["value"] = 777
    mymap["param"] = "Parameter"

    s = Sprintf("%v, %v, %v", myarr[0] + mymap["value"], myarr[1], mymap["param"])
    // s = 877, This is a line, Parameter 

Кроме этого, вы можете определять массивы array и map перечислением элементов в [] (для array) и {} (для map).

.. code:: js

     var my map
     my={"key1": "value1", key2: i, "key3": $Name}
     var mya array
     mya=["value1", {key2: i}, $Name]

Вы можете подставлять такую инициализацию прямо в выражения - например в параметрах вызова функций.

.. code:: js

     DBFind...Where({id: 1})

Для ассоциативных массивов обязательно указание ключа - он должен быть в виде строки в двойных кавычках. Если имя ключа содержит только буквы, цифры и подчеркивание, то двойные кавычки можно опускать.

.. code:: js

    {key1: "value1", key2: "value2"}

В качестве значений массивов можно указывать строки, числа, имена переменных любого типа и имена переменных со знаком доллара. Так как значением может быть другой map или array, то можно указывать инициализацию вложенных массивов. Нельзя указывать в качестве значений любые выражения. В таких случаях следует заводить промежуточную переменную.

.. code:: js

     [1+2, myfunc(), name["param"]] // нельзя
     [1, 3.4, mystr, "string", $ext, myarr, mymap, {"ids": [1,2, i], company: {"Name": "MyCompany"}} ] // можно
     
     var val string
     val = my["param"]
     MyFunc({key: val, sub: {name: "My name", "color": "Red"}})

Конструкции if и while
----------------------

Язык описания контрактов содержит стандартные условную конструкцию **if** и конструкцию цикла **while**, которые используются внутри функций, и контрактов. Эти конструкции могут вкладывать друг в друга. 

После ключевого слова должно идти условное выражение. Если условное выражение возвращает число, то оно считается *ложь* при значении 0. Например, *val == 0* эквивалентно *!val*, а *val != 0* тоже самое, что просто *val*. Конструкция **if** может иметь блоки **elif** и блок **else**, который выполняется если условное выражение **if** ложно. Блоки **elif** должны содержать очередное проверяемое условие. В условном выражении можно использовать операции сравнения: ``<, >, >=, <=, ==, !=``, а также ``||`` (ИЛИ) и ``&&`` (И).

.. code:: js

    if val > 10 || id != $citizen {
      ...
    } elif val == 5 {
       ...
    } elif val < 0 {
       ...
    } else {
      ...
    }

Конструкция **while** предназначена для реализации циклов. Блок **while** выполняется до тех пор, пока его условие истинно. Для прекращения цикла внутри блока используется оператор **break**. Для исполнения блока цикла сначала используется оператор **continue**.

.. code:: js

  while true {
      if i > 100 {
         break
      }
      ...
      if i == 50 {
         continue
      }
      ...
  }

Кроме условных выражений, язык поддерживает стандартные арифметические действия: ``+,-,*,/``
Если в качестве условия вы укажете переменную типа **string** или **bytes**, то условие будет истино, если длина строки (bytes) больше нуля. На пустой строке условие будет ложь.


Функции
-------

Функции языка написания контрактов выполняют операции с данными, полученными в секции ``data`` контракта: чтение значений из базы данных и запись значений в базу данных, преобразование типов значений и установление связи между контрактами. 

Функция определяется с помощью ключевого слова **func**, после которого указывается имя функции, в круглых скобках через запятую передаваемые параметры с указанием типа, после закрывающей скобки - тип возвращаемого значения. Тело функции заключается в фигурные скобки. Если функция не имеет параметров, то круглые скобки можно опустить. Для возврата значения из функции используется ключевое слово ``return``.

.. code:: js

  func myfunc(left int, right int) int {
      return left*right + left - right
  }
  func test int {
      return myfunc(10, 30) + myfunc(20, 50)
  }
  func ooops {
      error "Ooops..."
  }


Функции не возвращают ошибок, так как все проверки на ошибки происходят автоматически.
При генерации ошибки в любой из функции, контракт прекращает свою работу и выводит описание ошибки в специальном окне.
Ошибки при выполнении любой функции обрабатываются автоматически, вызывая остановку выполнения контракта и вывод соответствующего сообщения.

Имеется возможность передавать функции неопределенное количество параметров. Для этого у последнего параметра необходимо вместо типа указать ``...``. В этом случае, последний параметр будет иметь тип *array* и содержать все, начиная с данного параметра, указанные при вызове переменные. Можно передавать переменные любых типов, но вы должны самостоятельно предотвращать конфликты выполнения из-за несовпадений типов.

.. code:: js

  func sum(out string, values ...) {
      var i, res int
      
      while i < Len(values) {
         res = res + values[i]
         i = i + 1
      }
      Println(out, res)
  }

  func main() {
     sum("Sum:", 10, 20, 30, 40)
  }

Рассмотрим ситуацию, когда функция может иметь много параметров, но часто при вызове необходимо указывать только некоторые из них. В этом случае,опциональные параметры можно описывать следующим образом ``func myfunc(name string).Param1(param string).Param2(param2 int) {...}``. При вызове вы можете в любом порядке указывать только некоторые из дополнительных параметров ``myfunc("name").Param2(100)``. В теле функции вы как обычно можете обращаться к этим переменным. Если при вызове расширенный параметр не указан, то он принимает значение по умолчанию, например, пустая строка для строки и ноль для числа. Также, следует заметить, что можно указывать несколько расширенных параметров и использовать ``...`` - ``func DBFind(table string).Where(params map)`` и вызов ``DBFind("mytable").Where({id: {"$gt": myid}, type: 2)``

.. code:: js
 
    func DBFind(table string).Columns(columns string).Where(params map)
             .Limit(limit int).Offset(offset int) string  {
       ...
    }
     
Некоторые предопределенные функции позволяют передавать неопределенное количество параметров. Имеется возможноть динамически формировать и передавать список параметров. Для этого необходимо записать их в переменную типа *array* и передать её с троеточием. 

.. code:: js
 
    var names, values array
    ...
    MyFunc("mytable", Join(names, ","), values...)

Предопределенные переменные
---------------------------

При выполнении контракта доступны следующие переменные.

* ``$key_id`` - числовой идентификатор (int64) аккаунта, от которого подписана транзакциюя,
* ``$role_id`` - код роли, под которой зашел пользователь
* ``$ecosystem_id`` - идентификатор экосистемы, в которой была создана транзакция, 
* ``$type`` - идентификатор вызываемого контракта. Если, например, контракт вызвал другой контракт, то здесь будет хранится идентификатор оригинального контракта,
* ``$time`` - время указанное в транзакции в формате Unix,
* ``$block`` - номер блока, в котором запечаталась данная транзакция, 
* ``$block_time`` - время указанное в блоке, 
* ``$block_key_id`` - числовой идентифкатор (int64) ноды, которая подписала блок,
* ``$auth_token`` - токен авторизации, который можно использовать в VDE контрактах, например, при вызове контрактов через api c помощью функции ``HTTPRequest``.

.. code:: js

	var pars, heads map
	heads["Authorization"] = "Bearer " + $auth_token
	pars["vde"] = "false"
	ret = HTTPRequest("http://localhost:7079/api/v2/node/mycontract", "POST", heads, pars)

Предопределенные переменные доступны не только в контрактах, но и в полях Permissions, в которых указываются условия доступа к элементам приложений (таблицам, контрактам, страницам и пр.) для составления логических выражений. При этом переменные имеющие отношения к формированию блока (*$time*, *$block* и др.) имеют нулевое значение.

Предопределенная переменной ``$result`` используется при необходимости возвратить значение из вложенного контракта.

Получение значений из таблиц базы данных
========================================

AppParam(app int, name string) string
-------------------------------------

Функция возвращает значение указанного параметра из параметров приложения (таблица *app_params*). 

* *app* - идентификатор приложения,
* *name* - имя получаемого параметра,

.. code:: js

    Println( AppParam(1, "app_account"))

DBFind(table string) [.Columns(columns array|string)] [.Where(where map)] [.WhereId(id int)] [.Order(order string)] [.Limit(limit int)] [.Offset(offset int)] [.Ecosystem(ecosystemid int)] array
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Функция возвращает массив *array* из таблицы базы данных *table* в соответствии с указанным запросом. Массив *array* состоит из ассоциативных массивов *map*, содержащих данные из записей таблицы. Для получения массива *map* первого элемента (первой записи запроса) используется функция ``.Row()``. Единичное    значение колонки с именем *column* из первого элемента массива возвращается добавлением функции ``.One(column string)``.

* *table* - имя таблицы,
* *сolumns* - список возвращаемых колонок, можно указать в виде массива array или в виде строки с перечислением  через запятую. Если не указано, то возвратятся все колонки, 
* *Where* - условие поиска. Например, ``.Where({name: "John"})`` или  ``.Where({"id": {"$gte": 4}})``,

В параметр **where** должен передаваться ассоциативный массив, в котором описаны условия поиска. Массив может состоять из элементов любой вложенности. Имеются следующие управляющие конструкции:

* **{"field1": "value1", "field2" : "value2} → field1 = "value1" AND field2 = "value2**
* **{"field1": {"$eq":"value"}} → field = "value"**
* **{"field1": {"$neq": "value"}} → field != "value"**
* **{"field1: {"$in": [1,2,3]} → field IN (1,2,3)**
* **{"field1": {"$nin" : [1,2,3]} → field NOT IN (1,2,3)**
* **{"field": {"$lt": 12}} → field < 12**
* **{"field": {"$lte": 12}} → field <= 12**
* **{"field": {"$gt": 12}} → field > 12**
* **{"field": {"$gte": 12}} → field >= 12**
* **{"$and": [<expr1>, <expr2>, <expr3>]} → expr1 AND expr2 AND expr3**
* **{"$or": [<expr1>, <expr2>, <expr3>]} → expr1 OR expr2 OR expr3**
* **{field: {"$like": "value"}} → field like '%value%' (поиск подстроки)**
* **{field: {"$begin": "value"}} → field like 'value%' (начинается с value)**
* **{field: {"$end": "value"}} → field like '%value' (заканчивается value)**
* **{field: "$isnull"} → field is null**

Имеется ещё один момент. Предположим есть запрос *id>2 and id<5*. Написать так *{id:{"$gt": 2}, id:{"$lt": 5}}*
нельзя, так как у нас в массиве второе присваивание ключа перекроет первое и останется только *id<5*.
В этом случае можно применять один из двух способов.

.. code:: js

     1. {"$and": [{id:{"$gt": 2}}, {id:{"$lt": 5}}]}
     2. {id: [{"$gt": 2}, {"$lt": 5}]}

второй способ более короткий - мы все варианты для колонки указываем в виде массива.

* *id* - поиск по идентификатору. Достаточно указать значение идентификатора.  Например, ``.WhereId(1)``,
* *order* - поле, по которому нужно отсортировать. По умолчанию, сортируется по *id*. Если сортируется только по одному полю, то его можно указать в качестве строки. В противном случае, необходимо передавать массив строк и объектов *{"field": "-1"}* или *{"field": "1"}*. *{"field": "-1"}* = *field desc*, *{"field": "1"}* = *field asc*. Например, **.Order({name: "-1"}, {amount: "1"})**
* *limit* - количество возвращаемых записей. По умолчанию, 25. Максимально возможное количество - 250,
* *offset* - смещение возвращаемых записей,
* *ecosystemid* - идентификатор экосистемы. По умолчанию, берутся данные из таблицы в текущей экосистеме.

.. code:: js

   var i int
   ret = DBFind("contracts").Columns(["id","value"]).Where({id: [{"$gt": 3}, {"$lt":8}]}).Order("id")
   while i < Len(ret) {
       var vals map
       vals = ret[0]
       Println(vals["value"])
       i = i + 1
   }
   
   var ret string
   ret = DBFind("contracts").Columns("id,value").WhereId(10).One("value")
   if ret != nil { 
   	Println(ret) 
   }

DBRow(table string) [.Columns(columns array|string)] [.Where(where map)] [.WhereId(id int)] [.Order(order array|string)] [.Ecosystem(ecosystemid int)] map
----------------------------------------------------------------------------------------------------------------------------------------------------------

Функция возвращает ассоциативный массив *map*, с данными полученными из таблицы *table* в соответствии с указанным запросом.

* *table* - имя таблицы,
* *сolumns* - список возвращаемых колонок, можно указать в виде массива array или в виде строки с перечислением  через запятую. Если не указано, то возвратятся все колонки, 
* *Where* - условие поиска, подробнее описано в функции **DBFind**; например, ``.Where({name: "John"})`` или  ``.Where({"id": {"$gte": 4}})``,
* *id* - идентификатор возвращаемой строки; например, ``.WhereId(1)``,
* *order* - поле по которому производится сортировка; по умолчанию, сортируется по *id*. Более подробно описано в функции **DBFind**.
* *ecosystemid* - идентификатор экосистемы; по умолчанию,  id текущей экосистемы.

.. code:: js

   var ret map
   ret = DBRow("contracts").Columns(["id","value"]).Where({id: 1})
   Println(ret)

DBSelectMetrics(metric string, timeInterval string, aggregateFunc string) array
-------------------------------------------------------------------------------

Функция возвращает массив *array* с агрегированными данными для метрики *metric* за указанный интревал времени *timeInterval*, агрегация осуществляется через функцию *aggregateFunc*. Массив *array* состоит из ассоциативных массивов *map*, содержащих данные *key* - ключ, *value* - значение.

Названия метрик:

* *ecosystem_pages* - кол-во страниц экосистемы, *key* - номер экосистемы, *value* - значение,
* *ecosystem_members* - кол-во участников экосистемы, *key* - номер экосистемы, *value* - значение,
* *ecosystem_tx* - кол-во транзакций экосистемы, *key* - номер экосистемы, *value* - значение.

Метрики обновляются через каждые 100 блоков и хранятся в разрезе за каждый день.

* *metric* - название метрики,
* *timeInterval* - интервал вермени, за который требуется получить значения метрик. Например, ``1 day`` или ``30 days``, 
* *aggregateFunc* - функция агрегации. Например, ``max``, ``min`` или ``avg``,

.. code:: js

   var rows array
   rows = DBSelectMetrics("ecosystem_tx", "30 days", "avg")
   
   var i int
   while(i < Len(rows)) {
      var row map
      row = rows[i] // row содержит map, с ключами key и value, где key - номер экосистемы, value - среднее кол-во транзакций за 30 дней
      i = i + 1
   }

EcosysParam(name string) string
-------------------------------

Функция возвращает значение указанного параметра из настроек экосистемы (таблица *parameters*). 

* *name* - имя получаемого параметра,
* *num* - порядковый номер параметра.

.. code:: js

    Println( EcosysParam("gov_account"))

GetHistory(table string, id int) array 
--------------------------------------

GetHistoryRow(table string, id int, rollbackId int) map 
-------------------------------------------------------

Функция возвращает массив ассоциативных массивов типа *map* c историей изменений записи в указанной таблице c именем **table**. Каждый ассоциативный массив содержит поля записи перед очередным изменением. Результирующий список отсортирован от последних изменений к более ранним. В результирующей таблице поле *id* указывает на id в таблице *rollback_tx*. Также возвращаются поля *block_id* - номер блока, *block_time* - время блока.
Функция **GetHistoryRow** возвращает только одну запись c указанным идентификатором в таблице *rollback_tx* в виде ассоциативного массива map.

* *table* - имя таблицы.
* *id* - идентификатор записи.
* *RollbackId* - (для функции **GetHistoryRow**) идентификатор записи id в таблице *rollback_tx*.

.. code:: js

    var list array
    var item map
    list = GetHistory("blocks", 1)
    if Len(list) > 0 {
       item = list[0]
    }

GetColumnType(table, column string) string
------------------------------------------

Функция возвращает тип указанной колонки в указанной таблице. Возвращается наименование внутреннего типа -например, *text,varchar,number,money,double,bytea,json,datetime,double*.

* *table* - имя таблицы,
* *column* - имя колонки.

.. code:: js

    var coltype string
    coltype = GetColumnType("members", "member_name")
	
GetDataFromXLSX(binId int, line int, count int, sheet int) string
-----------------------------------------------------------------

Функция возвращает данные в виде массива массивов ячеек из таблицы XLSX.

* *binId* - идентификатор загруженной XLSX таблицы из таблицы *binary*,
* *line* - строка c которой необходимо получить данные, счёт с нуля,
* *count* - количество возвращаемых строк,
* *sheet* - номер листа в XLSX файле, счёт с 1.

.. code:: js

    var a array
    a = GetDataFromXLSX(binid, 12, 10, 1)

GetRowsCountXLSX(binId int, sheet int) int
------------------------------------------

Функция возвращает количество строк на указанном листе в XLSX файле.

* *binId* - идентификатор загруженной XLSX таблицы из таблицы *binary*,
* *sheet* - номер листа в XLSX файле, счёт с 1.

.. code:: js

    var count int
    count = GetRowsCountXLSX(binid, 1)

LangRes(label string, lang string) string
----------------------------------------------------

Функция возвращает языковой ресурс с именем label для языка lang, заданного двухсимвольным кодом, например, *en,fr,ru*. Если для указанного языка нет ресурса, то возвращается значение на английском языке. Используется для перевода текста в всплывающих окнах, инициируемых контрактами.

* *label* - имя языкового ресурса.
* *lang* - двухсимвольный код языка.

.. code:: js

    warning LangRes("confirm", $Lang)
    error LangRes("problems", "de")
    
GetBlock(blockID int64) map
---------------------------

Функция возвращает информацию о блоке *blockID*. Информация возвращается в виде ассоциативного массива *map*, содержащего данные:

* *id* - номер блока,
* *time* - время генерации блока в Unix,
* *key_id* - ключ ноды, которая сгенерировала блок.

.. code:: js

   var b map
   b = GetBlock(1)
   Println(b)
	
Изменение значений в таблицах базы данных
=========================================

DBInsert(table string, params map) int
--------------------------------------

Функция добавляет запись в таблицу *table* и возвращает **id** вставленной записи.

* *tblname* - имя таблицы в базе данных,
* *params* - ассоциативный массив *map*, в котором в качестве ключей передаются имена полей и соответствующие им значения. 

.. code:: js

    DBInsert("mytable", {name: "John Dow", amount: 100})

DBUpdate(tblname string, id int, params map)
--------------------------------------------

Функция изменяет значения столбцов в таблице в записи с указанным **id**. Если записи с таким идентификатором не существует, то будет выдаваться ошибка.

* *tblname* - имя таблицы в базе данных,
* *id* - идентификатор **id** изменяемой записи,
* *params* - ассоциативный массив *map*, в котором в качестве ключей передаются имена полей и соответствующие им значения. 

.. code:: js

    DBUpdate("mytable", myid, {name: "John Dow", amount: 100})

DBUpdateExt(tblname string, column string, value (int|string), params map)
--------------------------------------------------------------------------

Функция обновляет столбцы в записи, у которой колонка имеет заданное значение. Таблица должна иметь индекс по указанной колонке.

* *tblname* - имя таблицы в базе данных,
* *column* - имя колонки, по которой будет идти поиск записи,
* *value* - значение для поиска записи в колонке,
* *params* - ассоциативный массив *map*, в котором в качестве ключей передаются имена полей и соответствующие им значения. 

.. code:: js

    DBUpdateExt("mytable", "address", addr, {name: "John Dow", amount: 100})
    
DelColumn(tblname string, column string)
--------------------------------------------

Функция удаляет столбец в указанной таблице. Таблица не должна содержать записей.

* *tblname* - имя таблицы в базе данных,
* *column* - имя удаляемой колонки.

.. code:: js

    DelColumn("mytable", "mycolumn")

DelTable(tblname string)
--------------------------------------------

Функция удаляет указанную таблицу. Таблица не должна содержать записей.

* *tblname* - имя таблицы в базе данных.

.. code:: js

    DelTable("mytable")

Операции с массивами
====================

Append(src array, val someType) array
-------------------------------------

Функция вставляетв src значение val любого типа и возвращает результирующий массив

* *src* - исходный массив
* *val* - значение, которое необходимо добавить в массив

.. code:: js

  var list array
  list = Append(list, "new_val")

Join(in array, sep string) string
---------------------------------

Функция объединяет элементы массива *in* в строку с указанным разделителем *sep*.

* *in* - имя массива типа *array*, элементы которого необходимо объединить,
* *sep* - строка-разделитель.

.. code:: js

    var val string, myarr array
    myarr[0] = "first"
    myarr[1] = 10
    val = Join(myarr, ",")

Split(in string, sep string) array
----------------------------------

Функция возвращает массив, полученный из элементов строки *in*, при ее разбивании в соответствии с разделителем *sep*.

* *in* - исходная строка,
* *sep* - строка-разделитель.

.. code:: js

    var myarr array
    myarr = Split("first,second,third", ",")

Len(val array) int
------------------
Функция возвращает количество элементов в указанном массиве.

* *val* - массив типа *array*.

.. code:: js

    if Len(mylist) == 0 {
      ...
    }

Row(list array) map
-------------------

Функция возвращает первый ассоциативный массив *map* из массива *list*. Если список *list* пустой, то результат вернет пустой *map*. Используется преимущественно с функцией DBFind, в этом случае параметр *list* не указывается. 

* *list* - массив map, возвращаемый функцией **DBFind**.

.. code:: js

   var ret map
   ret = DBFind("contracts").Columns("id,value").WhereId(10).Row()
   Println(ret)

One(list array, column string) string
-------------------------------------

Функция возвращает значение ключа *column* из первого ассациативного массива в массиве *list*. Если список *list* пустой, то возвращается nil. Используется преимущественно с функцией DBFind, в этом случае параметр *list* не указывается. 

* *list* - массив map, возвращаемый функцией **DBFind**,
* *column* - имя возвращаемого ключа.

.. code:: js

   var ret string
   ret = DBFind("contracts").Columns("id,value").WhereId(10).One("value")
   if ret != nil {
      Println(ret)
   }
   
GetMapKeys(val map) array
-------------------------

Функция возвращает массив ключей из ассациативного массива *val*.

* *val* - массив map.

.. code:: js

   var val map
   var arr array
   val["k1"] = "v1"
   val["k2"] = "v2"
   arr = GetMapKeys(val)

SortedKeys(val map) array
-------------------------

Функция возвращает отсортированный массив ключей из ассациативного массива *val*.

* *val* - массив map.

.. code:: js

   var val map
   var arr array
   val["k1"] = "v1"
   val["k2"] = "v2"
   arr = SortedKeys(val)

Операции с контрактами и условиями
==================================

CallContract(name string, params map)
-------------------------------------

Функция вызывает контракт по его имени. В передаваемом массиве должны быть перечислены все параметры, указанные в section *data* контракта. Функция возвращает значение, которое было присвоено переменной **$result** в контракте.

* *name* - имя вызываемого контракта,
* *params* - ассоциативный массив с входными данными для контракта.

.. code:: js

    var par map
    par["Name"] = "My Name"
    CallContract("MyContract", par)

ContractAccess(name string, [name string]) bool
-----------------------------------------------

Функция проверяет, совпадает ли имя выполняемого контракта с одним из имен, перечисленных в параметрах. Используется для контроля доступа контрактов к таблицам. Функция прописывается в полях *Permissions* колонок таблицы или в полях *Insert* и *New Column* в разделе *Table permission*.

* *name* - имя контракта.

.. code:: js

    ContractAccess("MyContract")  
    ContractAccess("MyContract","SimpleContract") 
    
ContractConditions(name string, [name string]) bool
---------------------------------------------------

Функция вызывает секцию **conditions** контрактов с указанными именами (у контрактов секция *data* должен быть пустой). Если секция *conditions* выполнилась без ошибок, то возвращается *true*, в противном случае "false*. Функция используется в полях *Permissions* для задания прав доступа к соотвествующим операциям с элементами приложений (страницами, таблицами, контрактами и пр), а так же в секции *conditions* контрактов - если в процессе выполнения перечисленный в парараметрах контрактов сгенерировалась ошибка, то родительский контракт также завершится с данной ошибкой.

* *name* - имя контракта.

.. code:: js

    ContractConditions("MainCondition")  

EvalCondition(table string, name string, condfield string) 
----------------------------------------------------------

Функция берет из таблицы *table* значение поля *condfield* из записи с полем *'name'*, которое равно параметру *name*, и проверяет выполнено ли условие полученное из поля *condfield* или нет. Если условие не выполнено, то генерируется ошибка, с которой и завершается вызывающий контракт.

* *table* - имя таблица,
* *name* - значение для поиска по полю 'name',
* *condfield* - имя поля где хранится условие, которое необходимо будет проверить.

.. code:: js

    EvalCondition(`menu`, $Name, `condition`)  

GetContractById(id int) string
------------------------------
Функция возвращает имя контракта по его идентификатору. Если контракт не найден, то возвращается пустая строка.

* *id* - идентификатор контракта в таблице *contracts*.

.. code:: js

    var name string
    name = GetContractById($IdContract)  

GetContractByName(name string) int
----------------------------------

Функция возвращает идентификатор контракта в таблице *contracts* по его имени. Если контракт не найден, то возвращается ноль.

* *name* - идентификатор контракта в таблице *contracts*.

.. code:: js

    var id int
    id = GetContractByName(`NewBlock`) 

RoleAccess(id int, [id int]) bool
---------------------------------

Функция проверяет, совпадает ли идентификатор роли того, кто вызвал контракт, с одним из идентификаторов, перечисленных в параметрах. Используется для контроля доступа контрактов к таблицам и прочим данным.

* *id* - идентификатор роли.

.. code:: js

    RoleAccess(1)  
    RoleAccess(1, 3) 

TransactionInfo(hash: string)
-----------------------------

Функция ищет транзакцию по указанному хэшу и возвращает информацию о вызванном контракте и его параметрах. Функция возвращает строку в формате json *{"contract":"ContractName", "params":{"key": "val"}, "block": "N"}*, где в поле *contract* возвращается имя контракта, *params* - переданные параметры, *block* - номер блока в котором была обработана данная транзакция.

* *hash* - хэш транзакции в виде шестндцатеричной строки.

.. code:: js

    var out map
    out = JSONDecode(TransactionInfo(hash))

Throw(ErrorId: string, ErrDescription: string)
------------------------------
Функция генерирует ошибку выполнения типа *exception*, но добавляет туда дополнительное поле *id*. Результат выполнения такой транзакции будет иметь вид *{"type":"exception","error":"Error description","id":"Error ID"}*

* *ErrorId* - идентификатор ошибки.
* *ErrDescription* - описание ошибки.

.. code:: js

    Throw("Problem", "There is some problem")


ValidateCondition(condition string, ecosystemid int) 
----------------------------------------------------

Функция пытается скомпилировать условие, указанное в параметре *condition*. Если в процессе компиляции условия возникнет ошибка, то будет сгенерирована ошибка и вызывающий контракт закончит свою работу. Данная функция предназначена для проверки правильности условий при их изменении.

* *condition* - проверяемое условие,
* *ecosystemid* - идентифкатор экосистемы.

.. code:: js

    ValidateCondition(`ContractAccess("@1MyContract")`, 1)  


Операции с адресами аккаунтов
=============================
    
AddressToId(address string) int
-------------------------------
Функция возвращает числовой идентификатор владельца аккаунта по строковому значению адреса аккаунта. Если указан несуществующий адрес, то возвращается 0.

* *address* - адрес аккаунта в формате XXXX-...-XXXX или в виде числа.

.. code:: js

    account = AddressToId($Recipient)

HexToPub(hexpub string) bytes
--------------------------

Функция конвертирует шестнадцатеричную строку с публичным ключом в переменную типа *bytes*. При этом входящая стркоа может содержать в начале префикс '04'.

* *hexpub* - публичный ключ в шестнадцатеричном виде

.. code:: js

        pub = HexToPub(hexkey)


IdToAddress(id int) string
--------------------------

Функция возвращает строковый адрес аккаунта по числовому идентификатору его владельца. Если указан несуществующий id, то возвращается 'invalid'.

* *id* - числовой идентификатор.

.. code:: js

    $address = IdToAddress($id)

PubToHex(pub string | bytes) string
--------------------------

Функция конвертирует публичный ключ в шестнадцатеричную строку. При этом добавляется в начало строка '04'.

* *pub* - публичный ключ в двоичном виде

.. code:: js

        pub = DBFind("@1keys").Columns("pub").Where({id:"2367267345348734"}).One("pub")
        var hex string
        hex = PubToHex(pub)
    
PubToID(hexkey string) int
--------------------------

Функция возвращает числовой идентификатор владельца публичного ключа. При ошибке возвращает ноль.

* *hexkey* - публичный ключ в виде шестнадцатиричной строки

.. code:: js

    var keyId int
    keyId = PubToID("fa5e78.....34abd6")    
    

Операции со значениями переменных
=================================

DecodeBase64(input string) string
---------------------------------

Функция раскодирует строку в кодировке base64.

* *input* - входящая строка в кодировке base64.

.. code:: js

    val = DecodeBase64(mybase64)
    
EncodeBase64(input string) string
---------------------------------

Функция кодирует строку в кодировку base64 и возвращает строку в закодированном виде.

* *input* - входящая строка.

.. code:: js

    var base64str string
    base64str = EncodeBase64("my text")

Float(val int|string) float
---------------------------

Функция преобразует целое число *int* или *string* в число с плавающей точкой.

* *val* - целое число или строка.

.. code:: js

    val = Float("567.989") + Float(232)

HexToBytes(hexdata string) bytes
--------------------------------

Функция преобразует строку с шестнадцатеричной кодировкой в значение  типа *bytes* (последовательность байт).

* *hexdata* - строка, содержащая шестнадцатеричную запись.

.. code:: js

    var val bytes
    val = HexToBytes("34fe4501a4d80094")
    
FormatMoney(exp string, digit int) 
------------------------------
Функция возвращает строковое значение exp/10^digit. Если параметр digit не указан, то он будет браться из параметра **money_digit** экосистемы.

* *exp* - Числововое значение в виде строки,
* *digit* - степень 10 в выражении exp/10^digit. Может быть как положительным, так и отрицательным. В случае положительного значения определяет количество цифр после запятой.

.. code:: js

       s = FormatMoney("123456723722323332", 0)
    

Random(min int, max int) int
----------------------------

Функция возвращает случайное число в диапазоне между min и max (min <= result < max). min и max должны быть положительными числами.

* *min* - минимальное значение случайного числа,
* *max* - Случайное значение будет меньше этого числа.

.. code:: js

    i = Random(10,5000)


Int(val string) int
-------------------

Функция преобразует строковое значение в целое число.

* *val* - строка содержащая число.

.. code:: js

    mystr = "-37763499007332"
    val = Int(mystr)
    

Hash(val interface{}) string, error
-----------------------------------

Функция принимает массив байт или строку и возвращает Hash, полученный с помощью системного криптопровайдера.

* *val* - входящая строка или массив байт

.. code:: js

    var hash string
    hash = Hash("Test message")

Sha256(val string) string
-------------------------

Функция возвращает хэш **SHA256** от указанной строки.

* *val* - входящая строка, для которой нужно вычислить хэш **Sha256**.

.. code:: js

    var sha string
    sha = Sha256("Test message")

Str(val int|float) string
-------------------------

Функция преобразует числовое значение типа *int* или *float* в строку.

* *val* - целое или число с плавающей точкой.

.. code:: js

    myfloat = 5.678
    val = Str(myfloat)

UpdateLang(appID int, name string, trans string)
------------------------------------------------

Функция обновляет языковой ресурс в памяти. Используется в транзакциях, которые меняют языковые ресурсы.

* *appID* - id приложения.
* *name* - имя языкового ресурса.
* *trans* - ресурс с переводами.

.. code:: js

    UpdateLang($AppID, $Name, $Trans)

Операции с JSON
===============

JSONEncode(src int|float|string|map|array) string
-------------------------------------------------

Функция конвертирует число, строку или массив *src* в строку в формате JSON.

* *src* - Данные которые требуется конвертировать в JSON.

.. code:: js

    var mydata map
    mydata["key"] = 1
    var json string
    json = JSONEncode(mydata)

JSONEncodeIndent(src int|float|string|map|array, indent string) string
----------------------------------------------------------------------

Функция конвертирует число, строку или массив *src* в строку в формате JSON с указанными отступами.

* *src* - Данные которые требуется конвертировать в JSON,
* *indent* - Строка, которая будет использоваться в качестве отступов.

.. code:: js

    var mydata map
    mydata["key"] = 1
    var json string
    json = JSONEncodeIndent(mydata, "\t")


JSONDecode(src string) int|float|string|map|array
-------------------------------------------------

Функция конвертирует строку *src* с данными в формате JSON в число, строку или массив.

* *src* - Строка с данными в JSON формате.

.. code:: js

    var mydata map
    mydata = JSONDecode(`{"name": "John Smith", "company": "Smith's company"}`)

Операции со строковыми значениями
=================================

HasPrefix(s string, prefix string) bool
---------------------------------------

Функция возвращает true, если строка начинается с указанной подстроки *prefix*.

* *s* - проверяема строка,
* *prefix* - проверяемый префикс у данной строки.

.. code:: js

    if HasPrefix($Name, `my`) {
    ...
    }

Contains(s string, substr string) bool
--------------------------------------

Функция возвращает true, если строка *s* содержит подстроку *substr*.

* *s* - проверяема строка,
* *substr* - подстрока, которая ищется в указанной строке.

.. code:: js

    if Contains($Name, `my`) {
    ...
    }    
 
Replace(s string, old string, new string) string
------------------------------------------------

Функция заменять в строке *s* все вхождения строки *old* на строку *new* и возвращает полученный результат.

* *s* - исходная строка,
* *old* - заменяемая строка,
* *new* - новая строка.

.. code:: js

    s = Replace($Name, `me`, `you`)

Size(val string) int
--------------------

Функция возвращает количество символов в указанной строке.

* *val* - входящая строка.

.. code:: js

    var len int
    len = Size($Name)

Sprintf(pattern string, val ...) string
---------------------------------------

Функция формирует строку на основе указанного шаблона и параметров, можно использовать ``%d`` (число), ``%s`` (строка), ``%f`` (float), ``%v`` (для любых типов).

* *pattern* - шаблон для формирования строки.

.. code:: js

    out = Sprintf("%s=%d", mypar, 6448)

Substr(s string, offset int, length int) string
-----------------------------------------------

Функция возвращает подстроку от указанной строки начиная со смещения *offset* (cчитается с 0) и длиной *length*. В случае некорректных смещений или длины возвращается пустая строка. Если сумма смещения и *length* больше размера строки, то возвратится подстрока от смещения до конца строки.

* *val* - входящая строка,
* *offset* - начальное смещение подстроки,
* *length* - размер подстроки.

.. code:: js

    var s string
    s = Substr($Name, 1, 10)
    
ToLower(val string) string
--------------------------

Функция возвращает указанную строку в нижнем регистре .

* *val* - входящая строка.

.. code:: js

    val = ToLower(val)    

ToUpper(val string) string
--------------------------

Функция возвращает указанную строку в верхнем регистре .

* *val* - входящая строка.

.. code:: js

    val = ToUpper(val)    

TrimSpace(val string) string
----------------------------

Функция возвращает указанную строку с удаленными начальными и конечными пробелами, переводами строки и знаками табуляции.

* *val* - входящая строка.

.. code:: js

    val = TrimSpace(val)    

Операции с байтами
==================

StringToBytes(src string) bytes
-------------------------------

Функция преобразует строку в байты.

* *src* - строка.

.. code:: js

    var b bytes
    b = StringToBytes("my string")

BytesToString(src bytes) string
-------------------------------

Функция преобразует байты в строку.

* *src* - байты.

.. code:: js

    var s string
    s = BytesToString($Bytes)

Операции с системными параметрами
=================================

SysParamString(name string) string
----------------------------------

Функция возвращает значение указанного системного параметра.

* *name* - имя параметра.

.. code:: js

    url = SysParamString(`blockchain_url`)

SysParamInt(name string) int
----------------------------

Функция возвращает значение указанного системного параметра в виде числа.

* *name* - имя параметра.

.. code:: js

    maxcol = SysParam(`max_columns`)

DBUpdateSysParam(name, value, conditions string)
------------------------------------------------

Функция обновляет значение и условие системного параметра. Если значение или условие менять не нужно, то в соответствующем параметре следует указать пустую строку.

* *name* - имя параметра,
* *value* - новое значение параметра,
* *conditions* - новое условие изменения параметра.

.. code:: js

    DBUpdateSysParam(`fuel_rate`, `400000000000`, ``)

UpdateNotifications(ecosystemID int, keys int ...)
--------------------------------------------------

Функция получает список уведомления для указанных ключей из базы данных и рассылает по этим ключам уведомления в центрифугу. 

* *ecosystemID* - идентификатор экосистемы,
* *key* - ключи через запятую, по которым проходит проверка. Можно отправить один массив array со списком ключей.

.. code:: js

    UpdateNotifications($ecosystem_id, $key_id, 23345355454, 35545454554)
    UpdateNotifications(1, [$key_id, 23345355454, 35545454554] )

UpdateRolesNotifications(ecosystemID int, roles int ...)
--------------------------------------------------------

Функция получает список уведомления для всех ключей из указанных ролей из базы данных и рассылает по этим ключам уведомления в центрифугу. 

* *ecosystemID* - идентификатор экосистемы,
* *roles* - идентификаторы ролей через запятую, по которым проходит проверка. Можно отправить один массив array со списком ролей.

.. code:: js

    UpdateRolesNotifications(1, 1, 2)

Работа с JSON в запросах к PostgreSQL
=====================================

В качестве типа колонок вы можете указывать тип **JSON**. В этом случае, если вы хотите обращаться к полям записи, вам следует использовать запись вида **имяколонки->имяполя**. Полученное значение будет записано в колонку с именем **имяколонки.имяполя**. Обращение **имяколонки->имяполя** можно использовать в параметрах *Columns,One,Where* при запросах **DBFind**.

.. code:: js

	var ret map
	var val str
	var list array
	ret = DBFind("mytable").Columns("myname,doc,doc->ind").WhereId($Id).Row()
	val = ret["doc.ind"]
	val = DBFind("mytable").Columns("myname,doc->type").WhereId($Id).One("doc->type")
	list = DBFind("mytable").Columns("myname,doc,doc->ind").Where("doc->ind = ?", "101")
	val = DBFind("mytable").WhereId($Id).One("doc->check")
		

Операции датой/временем в запросах к PostgreSQL
===============================================

Функции не дают возможности напрямую отправлять запросы с select, update и т.д., но они позволяют использовать возможности и функции PostgrеSQL при получении значений и описания условий where в выборках. Это относится в том числе и к функциям работающим с датами и временем. Например, необходимо сравнить колонку *date_column* и текущее время. Если *date_column* имеет тип timestamp, то выражение будет следующим ``date_column > now()``, а если *date_column* хранит время в Unix формате в виде числа, то тогда выражение будет ``to_timestamp(date_column) > now()``. 

.. code:: js

    to_timestamp(date_column) > now()
    date_initial < now() - 30 * interval '1 day'

Рассмотрим ситуацию, когда у нас есть значение в формате Unix и необходимо записать его в поле имеющее тип *timestamp*. В этом случае, при перечислении полей, перед именем данной колонки необходимо указать **timestamp**. 

.. code:: js

   DBInsert("mytable", "name,timestamp mytime", "John Dow", 146724678424 )

Если же вы имеете строковое значение времени и вам нужно записать его в поле с типом *timestamp*. В этом случае,  **timestamp** необходимо указать перед самим значением. 

.. code:: js

   DBInsert("mytable", "name,mytime", "John Dow", "timestamp 2017-05-20 00:00:00" )
   var date string
   date = "2017-05-20 00:00:00"
   DBInsert("mytable", "name,mytime", "John Dow", "timestamp " + date )
   DBInsert("mytable", "name,mytime", "John Dow", "timestamp " + $txtime )

BlockTime()
-----------
Функция возвращает время генерации блока в SQL формате. Данная функция должна использоваться вместо функции получения текущего времени NOW().

.. code:: js

    DBInsert(`mytable`, `created_at`, BlockTime())
    
DateTime(unixtime int) string
-----------------------------
Функция конвертирует unixtime в формат времени `YYYY-MM-DD HH\:MI\:SS`.

.. code:: js

    DateTime(1532325250)
    
UnixDateTime(datetime string) int
---------------------------------
Функция конвертирует строку с форматом времени `YYYY-MM-DD HH\:MI\:SS` в unixtime.

.. code:: js

    UnixDateTime("2018-07-20 14:23:10")

Функции для VDE
===============
Данные функции можно использовать только в контрактах virtual dedicated ecosystems (VDE).

HTTPRequest(url string, method string, heads map, pars map) string
------------------------------------------------------------------

Функция отправляет HTTP запрос на указанный адрес.

* *url* - адрес, на который будет отправлен запрос,
* *method* - метод запроса - GET или POST,
* *heads* - массив данных для формирования заголовка,
* *pars* - параметры.

.. code:: js

	var ret string 
	var pars, heads, json map
	heads["Authorization"] = "Bearer " + $auth_token
	pars["vde"] = "true"
	ret = HTTPRequest("http://localhost:7079/api/v2/content/page/default_page", "POST", heads, pars)
	json = JSONToMap(ret)

HTTPPostJSON(url string, heads map, pars string) string
-------------------------------------------------------

Функция подобна функции *HTTPRequest*, но отправляет *POST* запрос и параметры передаются одной строкой.

* *url* - адрес, куда будет отправлен запрос,
* *heads* - массив данных для формирования заголовка,
* *pars* - параметр в виде json строки.

.. code:: js

	var ret string 
	var heads, json map
	heads["Authorization"] = "Bearer " + $auth_token
	ret = HTTPPostJSON("http://localhost:7079/api/v2/content/page/default_page", heads, `{"vde":"true"}`)
	json = JSONToMap(ret)

Функции для мастера VDE
=======================
Данные функции можно использовать только в режиме VDEMaster

CreateVDE(VDEName string, DBUser string, DBPassword string, VDEAPIPort int)
---------------------------------------------------------------------------

Функция создает дочернюю VDE

* *VDEName* - имя VDE, может содержать только латиницу и цифры, без пробелов
* *DBUser* - имя роли для базы данных
* *DBPassword* - пароль для новой роли
* *VDEAPIPort* - порт для http запросов

ListVDE()
---------

Возвращает ассоциативный массив дочерних VDE, где в качестве ключа используется имя VDE, а в качестве значение статус процесса

RunVDE(VDEName string)
----------------------

Запускает процесс для VDE с именем VDEName

* *VDEName* - имя VDE, может содержать только латиницу и цифры, без пробелов

StopVDE(VDEName string)
-----------------------

Останавливает процесс для VDE с именем VDEName

* *VDEName* - имя VDE, может содержать только латиницу и цифры, без пробелов

RemoveVDE(VDEName string)
-------------------------

Удаляет процесс для VDE с именем VDEName, останавливает и удаляет связанный процесс

* *VDEName* - имя VDE, может содержать только латиницу и цифры, без пробелов

************************************************
Системные контракты
************************************************
Системные контракты создаются по умолчанию при установке платформы в экосистеме №1. Поэтому при вызове их из других экосистем необходимо указывать полное имя, например, ``@1NewContract``. Также, следует заметить, что страницы могут подгружаться из других экосистем. Если на странице имеются кнопки или ссылки для вызова контрактов, то они не будут работать при подгрузке с других экосистем. В этом случае, нужно также явно указывать экосистему вместе с именем контракта.

Список системных контрактов
===========================

NewEcosystem
------------
Контракт создает создает новую экосистему. Для получения идентификатора созданной экосистемы необходимо обратиться к полю *result*, которое возвращается в txstatus. Параметры:
   
* *Name string* - имя экосистемы (можно изменить в дальнейшем).

EditEcosystemName
-----------------

Контракт позволяет изменить имя экосистемы в таблице 1_ecosystems, таблица присутствует только в первой экосистеме
* *SystemID* - код экосистемы, имя которой требуется изменить
* *NewName* - новое имя экосистемы

MoneyTransfer
-------------

Контракт переводит токены платформы с аккаунта текущего пользователя на указанный аккаунт в первой экосистеме. Для перевода необходимо иметь на счету дополнительно 0.1 APL из которых будет оплачена комиссия за перевод. Параметры:

* *Recipient string* - акканут получателя в любом формате - число или ``XXXX-....-XXXX``,
* *Amount    string* - сумма переводимых токенов,
* *Comment   string "optional"* - комментарий.

NewContract
-----------

Контракт создает новый контракт в текущей экосистеме. Параметры:

* *Value string* - текст контракта. На верхнем уровне должен быть только один контракт. 
* *Conditions string* - условие изменения контракта.
* *Wallet string "optional"* - идентификатор аккаунта пльзователя, к которому планируется привязать контракт (по умолчанию основателя экосистемы).
* *TokenEcosystem int "optional"* - идентификатор экосистемы в токенах которой будет происходить оплата, если контракт будет активрован.

EditContract
------------

Изменение контракта в текущей экосистеме. Параметры:
      
* *Id int* - идентификатор изменяемого контракта,
* *Value string "optional"* - текст контракта или контрактов,
* *Conditions string "optional"* - права доступа на изменение контракта. 

BindWallet
----------------

Привязка контракта к аккаунту в текущей экосистеме. Привязка возможна с к аккаунту, который был указан при создании контракта. После привязки, с указанного аккаунта будет оплачивать выполнение данного контракта. Параметры:
      
* *Id int* - идентификатор привязываемого контракта.

UnbindWallet
------------------

Отвязка  контракта от аккаунта в текущей экосистеме. Отвязка возможна с того  аккаунта, к которому был привязан контракт. После отвязки контракта, его выполнение будут оплачивать вызывающие его пользователи. Параметры:
      
* *Id int* - идентификатор отвязываемого контракта.

NewParameter
------------

Контракт добавляет новый параметр к текущей экосистеме. Параметры:

* *Name string* - имя параметра,
* *Value string* - значение параметра,
* *Conditions string* - права на изменение параметра.

EditParameter
-------------

Контракт изменяет существующий параметр в текущей экосистеме. Параметры:

* *Name string* - имя изменяемого параметра,
* *Value string* - новое значение параметра,
* *Conditions string* - новые права на изменение параметра.

NewMenu
-------

Контракт добавляет новое меню к текущей экосистеме. Параметры:

* *Name string* - имя меню,
* *Value string* - текст меню,
* *Title string "optional"* - заголовок меню,
* *Conditions string* - права на изменение меню.

EditMenu
--------

Контракт изменяет существующее меню в текущей экосистеме. Параметры:

* *Id int* - идентификатор изменяемого меню,
* *Value string "optional"* - новай текст меню,
* *Title string "optional"* - заголовок меню,
* *Conditions string "optional"* - новое права на изменение меню.

AppendMenu
----------

Контракт добавляет текст к существующему меню в текущей экосистеме. Параметры:

* *Id int* - идентификатор дополняемого меню,
* *Value string* - добавляемый текст.

NewPage
-------

Контракт добавляет новую страницу в текущей экосистеме. Параметры:

* *Name string* - имя страницы,
* *Value string* - текст страницы,
* *Menu string* - имя меню, привязанного к данной странице,
* *Conditions string* - права на изменение страницы,
* *ValidateCount int "optional"* - кол-во нод для проверки валидности страницы, если параметр не задан, то используется значение из параметра экосистемы *min_page_validate_count*. Значение не может быть меньше *min_page_validate_count* и больше *max_page_validate_count*,
* *ValidateMode int "optional"* - количество проверок страниц. 0 - только при загрузке, 1 - при загрузке и при уходе со страницы.

EditPage
--------

Контракт изменяет существующую страницу в текущей экосистеме. Параметры:

* *Id int* - идентификатор изменяемой страницы,
* *Value string "optional"* - новый текст страницы,
* *Menu string "optional"* - имя нового меню страницы,
* *Conditions string "optional"* - новые права на изменение страницы,
* *ValidateCount int "optional"* - кол-во нод для проверки валидности страницы, если параметр не задан, то используется значение из параметра экосистемы *min_page_validate_count*. Значение не может быть меньше *min_page_validate_count* и больше *max_page_validate_count*.
* *ValidateMode string "optional"* - количество проверок страниц. 0 - только при загрузке, 1 - при загрузке и при уходе со страницы.

AppendPage
----------

Контракт добавляет текст к существующей странице текущей экосистеме. Параметры:

* *Id int* - идентификатор изменяемой страницы,
* *Value string* - добавляемый текст к странице.

NewBlock
--------

Контракт добавляет новый страничный блок в текущей экосистеме. Параметры:

* *Name string* - имя блока,
* *Value string* - текст блока,
* *Conditions string* - права на изменение блока.

EditBlock
---------

Контракт изменяет существующий блок в текущей экосистеме. Параметры:

* *Id int* - идентификатор изменяемого блока,
* *Value string "optional"* - новый текст блока,
* *Conditions string "optional"* - новые права на изменение блока.

NewTable
--------

Контракт добавляет новую таблицу в текущей экосистеме. Параметры:

* *Name string* - имя таблицы (только латинские символы),
* *Columns string* - массив колонок в JSON формате ``[{"name":"...", "type":"...","index": "0", "conditions":"..."},...]``, где

  * *name* - наименование колонки - латинские символы,
  * *type* - тип ``varchar, bytea, number, datetime, money, text, double, character``,
  * *index* - неиндексируемое поле  - "0", создать индекс - "1".
  * *conditions* - права на изменение данных в столбце; если необходимо указать права доступа на чтение, то нужно использовать JSON формат. Например, ``{"update":"ContractConditions(`MainCondition`)", "read":"ContractConditions(`MainCondition`)"}``

* *Permissions string* - права на доступ в JSON формате ``{"insert": "...", "new_column": "...", "update": "..."}``, где

  * *insert* - права на вставку записей,
  * *new_column* - права на добавление колонки,
  * *update* - права на изменение прав.

EditTable
---------

Контракт изменяет права на доступ к таблице в текущей экосистеме. Параметры:

* *Name string* - имя таблицы, 
* *Permissions string* - Разрешения на доступ в JSON формате ``{"insert": "...", "new_column": "...", "update": "..."}``, где

  * *insert* - права на вставку записей,
  * *new_column* - права на добавление колонки,
  * *update* - права на изменение прав.
   
NewColumn
---------

Контракт добавляет новую колонку к таблице в текущей экосистеме. Параметры:

* *TableName string* - имя таблицы,
* *Name* - наименование колонки (тольколатинские символы),
* *type* - тип ``varchar, bytea, number, datetime, money, text, double, character``,
* *Index* - неиндексируемое поле  - "0", создать индекс - "1",
* *Permissions* - права на изменение данных в столбце; если необходимо указать права доступа на чтение, то нужно использовать JSON формат, например, ``{"update":"ContractConditions(`MainCondition`)", "read":"ContractConditions(`MainCondition`)"}``.

EditColumn
----------

Контракт меняет права на изменение колонки в таблице в текущей экосистеме. Параметры:

* *TableName string* - имя таблицы,
* *Name* - имя колонки,
* *Permissions* - права на изменение значений в колонке, если необходимо указать права доступа на чтение, то нужно использовать JSON формат, например,  ``{"update":"ContractConditions(`MainCondition`)", "read":"ContractConditions(`MainCondition`)"}``.

NewLang
-------

Контракт добавляет языковые ресурсы в текущей экосистеме. Права на добавление определяются в параметре *changing_language* в настройках экосистемы. Параметры:

* *Name string* - имя языкового ресурса (только латинские символы).
* *Trans* - языковые ресурсы в виде строки в JSON формате, где ключ - двухсимвольный код языков, значение - перевод, например: ``{"en": "English text", "ru": "Английский текст"}``.
* *[Lang string]* - опциональный параметр. Указывает язык для сообщений об ошибках во время выполнения контракта.

EditLang
--------

Контракт обновляет языковой ресурс в текущей экосистеме. Права на обновление определяются в параметре *changing_language* в настройках экосистемы. Параметры


* *Id int* - ID языкового ресурса.
* *Name string* - имя языкового ресурса. 
* *Trans* - языковые ресурсы в виде строки в JSON формате, где ключ - двухсимвольный код языков, значение - перевод, например: ``{"en": "English text", "ru": "Английский текст"}``.
* *[Lang string]* - опциональный параметр. Указывает язык для сообщений об ошибках во время выполнения контракта.

NewSign
-------

Контракт создает данные для для контрактов с подписью в текущей экосистеме. Параметры:

* *Name string* - имя контракта, который будет использовать дополнительную подпись. 
* *Value string* - описание параметров в виде JSON строки, где 
    
  * *title* - текст сообщения,
  * *params* - массив параметров, которые показываются пользователю, где **name** - имя поля, **text** - описание параметра.
    
* *Conditions string* - права на изменение записи.

Пример значения *Value*

``{"title": "Would you like to sign?", "params":[{"name": "Receipient", "text": "Account"},{"name": "Amount", "text": "Amount(EGS)"}]}``

EditSign
--------

Контракт обновляет данные для для контрактов с подписью в текущей экосистеме. Параметры:

* *Id int* - идентификатор изменяемой подписи,
* *Value string* - новое значение параметров,
* *Conditions string* - новые права на изменение параметров подписи.

Import 
------

Контракт импортирует данные из файла \*.sim в экосистему. Параметры:

* *Data string* - импортируемые данные, полученные при экспорте приложений в \*.sim файл.

NewCron
-------

Контракт добавляет новую задачу в cron для запуска по таймеру. Контракт присутствует только в VDE системах. Параметры:

* *Cron string* - строка, определяющая запуск контракта по таймеру в формате *cron*,
* *Contract string* - имя запускаемого в VDE контракта, контракт не должен содержать параметров в секции ``data``,
* *Limit int* - необязательное поле, в котором можно указать количество запусков (пока не исполняется),
* *Till string* - необязательно поле с временем окончания задачи (пока не учитывается),
* *Conditions string* - права на изменение задачи.

EditCron
--------

Контракт изменяет настройки задачи в cron для запуска по таймеру. Контракт присутствует только в VDE системах. Параметры:

* *Id int* - идентификатор задачи,
* *Cron string* - строка, определяющая запуск контракта по таймеру в формате *cron*; чтобы отключить задачу, нужно не указывать этот параметр или указать пустую строку,
* *Contract string* - имя запускаемого VDE контракта, контракт не должен содержать параметров в секции ``data``,
* *Limit int* - необязательное поле, в котором можно указать количество запусков (пока не исполняется),
* *Till string* - необязательно поле с временем окончания задачи (пока не учитывается),
* *Conditions string* - новые права на изменение задачи.

NewAppParam
-----------

Контракт добавляет новый параметр приложения в текущей экосистеме. Параметры:

* *App int* - идентификатор приложения,
* *Name string* - имя параметра,
* *Value string* - значение параметра,
* *Conditions string* - права на изменение параметра.

EditAppParam
------------

Контракт изменяет существующий параметр приложения в текущей экосистеме. Параметры:

* *Id int* - идентификатор параметра,
* *Value string* - новое значение параметра,
* *Conditions string* - новые права на изменение параметра.

NewDelayedContract
------------------

Контракт добавляет новое задание в планировщик запуска отложенных контрактов. Планировщик запуска отложенных контрактов запускает необходимые контракты для текущего генерируемого блока. Параметры:

* *Contract string* - название контракта, который требуется запустить,
* *EveryBlock int* - шаг в блоках, через который требуется запускать контракт,
* *Conditions string* - права на изменение задания,
* *BlockID int "optional"* - номер блока в котором требуется запустить контракт, если не указан, то рассчитывается автоматически "текущий номер блока" + $EveryBlock,
* *Limit int "optional"* - лимит кол-ва запусков задания, если лимит не указан, то задание с запуском контракта будет выполняться неограниченное кол-во раз.

EditDelayedContract
-------------------

Контракт изменяет задание в планировщике запуска отложенных контрактов. Параметры:

* *Id int* - идентификатор задания,
* *Contract string* - название контракта, который требуется запустить,
* *EveryBlock int* - шаг в блоках, через который требуется запускать контракт,
* *Conditions string* - права на изменение задания,
* *BlockID int "optional"* - номер блока в котором требуется запустить контракт, если не указан, то рассчитывается автоматически "текущий номер блока" + $EveryBlock,
* *Limit int "optional"* - лимит кол-ва запусков задания, если лимит не указан, то задание с запуском контракта будет выполняться неограниченное кол-во раз,
* *Deleted int "optional"* - отключение задания, *1* - отключает, *0* - включает.

UploadBinary
------------

Контракт добавляет/перезаписывает статичный файл в X_binaries. При вызове контракта через HTTP API, требуется использовать ``multipart/form-data``, параметр ``DataMimeType`` будет использован из данных формы.

Параметры:

* *Name string* - название статичного файла,
* *Data bytes "file"* - содержимое статичного файла,
* *DataMimeType string "optional"* - mime тип статичного файла,
* *AppID int* - идентификатор приложения,
* *MemberID int "optional"* - идентификатор пользователя, по умолчанию 0.

Если DataMimeType не передан, то по умолчанию используется ``application/octet-stream``.
Если MemberID не передан, то статика является системной.
