################################################################################
Смарт-контракты
################################################################################
.. contents::
  :local:
  :depth: 2

Смарт-контракт (далее просто “контракт”) - это базовый элемент приложений, с помощью которого реализуется выполнение единичного действия (обычно записи в таблицу базы данных), инициированного в интерфейсе пользователем или другим контрактом. Все операции с данными в приложениях оформляются в виде системы контрактов, взаимодействующих через таблицы базы данных или путем вызова друг с друга в теле контракта.

Контракты пишутся на оригинальном (написаном разработчиками платформы) тьюринг-полном скриптовом языке Simvolio с компиляцией в байт-код. Язык содержит необходимый набор функций, операторов и конструкций  для реализации алгоритмов обработки данных и операций со значениями.

Контракты могут редактироваться  (если при его создании эта возможность не была запрещена указанием ``false`` в правах доступа к редактированию контракта). Операции с данными блокчейна выполняет актуальная (последняя по времени) версия контракта. Вся история изменений контрактов сохраняется в блокчейне и доступна в программном клиенте.

********************************************************************************
Структура контракта
********************************************************************************
Контракт определяется ключевым словом contract, после которого указывается имя контракта. Тело контракта заключается в фигурные скобки. Контракт состоит из трех секций: 

1. **data** - используется для описания входящих данных (имена переменных и их типы),
2. **conditions** - реализует проверку входных данных на корректность,
3. **action** - содержит описание действия контракта. 

Структура контракта:

.. code:: js

  contract MyContract {
      data {
          FromId address
          ToId   address
          Amount money
      }
      func conditions {
          ...
      }
      func action {
      }
  }


Cекция data
==============================

Входные данные контракта, а так же параметры формы для приема этих данных описываются в секции ``data``. 
Данные перечисляются построчно: сначала указывается имя переменной (передаются только переменные, а не массивы), затем тип и опционально через пробел в двойных кавычках параметры для построения формы интерфейса:

* *hidden* - скрытый элемент формы,
* *optional* - элемент формы без обязательного заполнения,
* *date* - поле выбора даты и времени,
* *polymap* - карта с выбором координат и областей,
* *map* - карта с возможностью отметить место,
* *image* - загрузка изображений,
* *text* - ввод текста или HTML-кода в поле textarea,
* *crypt:Field* - создание и шифрование приватного ключа для адресата указанного в поле ``Field``, если указано только ``crypt``, то приватный ключ создастся для того пользователя, который подписывает контракт,
* *address* - поле для ввода адреса кошелька,
* *signature:contractname* - строка для вызова контракта contractname, который требует подписи (подробно рассматриваются в специально разделе описания).

.. code:: js

  contract my {
    data {
        Name string 
        RequestId address
        Photo bytes "image optional"
        Amount money
        Private bytes "crypt:RequestId"
    }
    ...
  }
  
Секция conditions
==============================
в секции реализуется проверка входных данных с выводом сообщений об ошибках с помощью команд: ``error``, ``warning``, ``info``. Все эти команды генерируют ошибку, останавливающую работу контракта, но выводят в интерфейсе различные сообщения: *критическая ошибка*, *предупреждение*, и *информативная ошибка*. Например, 

.. code:: js

  if fuel == 0 {
        error "fuel cannot be zero!"
  }
  if money < limit {
        warning Sprintf("You don't have enough money: %v < %v", money, limit)
  }
  if idexist > 0 {
        info "You have been already registered"
  }

Секция action
==============================  
Секция action содержит основной программный код контракта выполняющий получение дополнительных данных и запись результата в таблицы базы данных. Например,

.. code:: js

	action {
		DBUpdate("keys", $key_id,"-amount", $amount)
		DBUpdate("keys", $recipient,"+amount,pub", $amount, $Pub)
	}

Кроме секции action контракт может содержать функцию **price**. Эта функция нужна для установления дополнительной стоимости в единицах топлива при выполнении контракта. Она может возвращать как число типа *int*, так и типа *money*. Возвращенное значение из функции price будет добавлено к стоимости выполнения контракта и умножено на коэффициент **fuel_rate**.

.. code:: js
	
	contract MyContract {
		action {
			DBUpdate("keys", $key_id,"-amount", $amount)
			DBUpdate("keys", $recipient,"+amount,pub", $amount, $Pub)
		}
		func price int {
		     return 10000
		}
	}

Переменные в контракте
==============================
Входные данные контракта, описанные в секции data,  передаются в другие секции через переменные с именами данных и с символом  ``$`` перед ними. Возможно определить и дополнительные переменные со знаком ``$``, которые будут глобальными в рамках выполнения контракта, включая вложенные контракты. 

В контракте доступны и предопределенные переменные, содержащие данные о транзакции, из которой был вызван данный контракт.

* ``$time`` - время транзакции int,
* ``$ecosystem_id`` - идентификатор экосистемы int,
* ``$block`` - номер блока, в который запечатана транзакция int,
* ``$key_id`` - адрес кошелька подписавшего транзакцию, если контракт вне экосистемы с ``ecosystem_id == 0``,
* ``$block_key_id`` - адрес ноды, сформировавшей блок, в который входит транзакция,
* ``$block_time`` - время формирования блока, который содержит транзакцию с текущим контрактом.
* ``$original_contract`` - имя контракта, который был изначально вызван при обработке транзакции. Если эта переменная равна пустой строке, то значит контракт вызван при проверке какого-то условия. Чтобы проверить, вызвался ли данный контракт другим контрактом или напрямую из транзакции, следует сравнить **$original_contract** и **$this_contract**. Если они равны, то значит контракт был вызван из транзакции.
* ``$this_contract`` - имя текущего выполняемого контракта. 

Предопределенные переменные доступны не только в контрактах, но и в полях Permissions, в которых указываются условия доступа к элементам приложений (таблицам, контрактам, страницам и пр.) для составления логических выражений. При этом переменные имеющие отношения к формированию блока (``$time``, ``$block`` и др.) имеют нулевое значение.

Предопределенная переменная ``$result`` используется при необходимости возвратить значение из вложенного контракта.

.. code:: js

  contract my {
    data {
        Name string 
        Amount money
    }
    func conditions {
        if $Amount <= 0 {
           error "Amount cannot be 0"
        }
        $ownerId = 1232
    }
    func action {
        DBUpdate("mytable", $ownerId, "name,amount", $Name, $Amount - 10 )
        DBUpdate("mytable2", $citizen, "amount", 10 )
    }
  }
  
********************************************************************************
Вложенные контракты
********************************************************************************
В секциях *conditions* и *action* контракта может быть вызван другой контракт с передачей ему данных из текущего контракта.  Вызов вложенного контракта возможен как непосредственно, с указанием параметров в скобках после его имени (``NameContract(Params)``), так и с помощью функции *CallContract*, для которой имя контракта передается через строковую переменную.

********************************************************************************
Контракты с подтверждением
********************************************************************************
Поскольку язык написания контрактов позволяет выполнять вложенные контракты, то существует возможность выполнения такого вложенного контракта без ведома пользователя запустившего внешний контракт, что может привести к подписи пользователем несанкционированных им транзакций, скажем перевода токенов со своего аккаунта.

К примеру, пусть имеется контракт перевода токенов *TokenTransfer*:

.. code:: js

    contract TokenTransfer {
        data {
          Recipient int
          Amount    money
        }
        ...
    }

Если в некотором контракте, запущенном пользователем, будет вписана строка  ``TokenTransfer("Recipient,Amount", 12345, 100)``, то будет осуществлен перевод 100 токенов на аккаунт 12345. При этом пользователь, подписывающий внешний контракт, останется не в курсе осуществленной транзакции. Исключить такую ситуацию возможно, если контракт TokenTransfer будет требовать получения дополнительной подписи пользователя при вызове его из других контрактов. Для этого необходимо:

1. Добавить в секцию ``data`` контракта *TokenTransfer* поле с именем **Signature** с параметрами ``optional`` и ``hidden``, которые позволяют не требовать дополнительной подписи при прямом вызове контракта, поскольку в поле **Signature** уже будет подпись.

.. code:: js

    contract TokenTransfer {
        data {
          Recipient int
          Amount    money
          Signature string "optional hidden"
        }
        ...
    }


2. Добавить в таблицу *Signatures* (на странице *Contracts with confirmation* программного клиента Molis) запись содержащую: 

* имя контракта *TokenTransfer*, 
* имена полей, значения которых будут показываться пользователю, и их текстовое описание, 
* текст, который будет выводиться при подтверждении. 
  
В текущем примере достаточно указать два поля **Recipient** и **Amount**:

* **Title**: Are you agree to send token this recipient?
* **Parameter**: *Receipient* Text: Wallet ID
* **Parameter**: *Amount* Text: Amount (qEGS)

Теперь если вставить вызов контракта ``TokenTransfer("Recipient, Amount", 12345, 100)``, то будет получена системная ошибка ``"Signature is not defined"``. Если же контракт будет вызван следующим образом ``TokenTransfer("Recipient, Amount, Signature", 12345, 100, "xxx...xxxxx")``, то возникнет ошибка при проверке подписи. При вызове контракта проверяется подпись следующих данных: *время оригинальной транзакции, id пользователя, значение полей указанных в таблице signatures*, и подделать эту подпись невозможно.

Для того, чтобы пользователь при вызове контракта *TokenTransfer* увидел подтверждение на перевод денег, во внешний контракт необходимо добавить поле с произвольным названием и типом ``string`` и дополнительным параметром ``signature:contractname``. При вызове вложенного контракта *TokenTransfer* необходимо просто передать этот параметр. Также следует иметь в виду, что параметры для вызова контракта с подтверждением должны также быть описаны в секции ``data`` внешнего контракта (они могут быть скрытыми, но они все равно будут отображаться при подтверждении). Например,

.. code:: js

    contract MyTest {
      data {
          Recipient int "hidden"
          Amount  money
          Signature string "signature:TokenTransfer"
      }
      func action {
          TokenTransfer("Recipient,Amount,Signature",$Recipient,$Amount,$Signature)
      }
    }

При отправке контракта *MyTest*, у пользователя будет запрошено дополнительное подтверждение для перевода суммы на указанный аккаунт. Если во вложенном контракте будут указаны другие значения, например ``TokenTransfer("Recipient,Amount,Signature",$Recipient, $Amount+10, $Signature)``, то будет получена ошибку, что подпись неверна.

********************************************************************************
Редактор контрактов
********************************************************************************
Контракты создаются и редактируются в специальном редакторе программного клиента Molis. При создании нового контракта в него уже вписана типовая структура с тремя секциями ``data, conditions, action``.  Редактор контрактов обеспечивает:

- написание кода контрактов (с подсветкой ключевых слов языка Simvolio),
- форматирование кода контракта,
- привязку контракта к виртуальному аккаунту, с которого будет происходить оплата его работы,
- задание прав на редактирование контракта,
- просмотр истории изменения контрактов с возможностью восстановления прежних версий.

********************************************************************************
Язык написания контрактов Simvolio
********************************************************************************

Язык написания контрактов Simvolio обеспечивает:

- объявление переменных с различными типами значений, а также простых и ассоциативных массивов: ``var, array, map``,
- использование условной конструкции ``if`` и конструкции цикла ``while``,
- получение значений из базы данных и запись значений в базу данных ``DBFind, DBInsert, DBUpdate``,
- работу с контрактами,
- преобразование значений переменных,
- операции со строковыми значениями.

Базовые элементы и конструкции языка
==============================
Типы значений и переменные 
------------------------------
Переменные языка объявляются с указанием типа значения. В очевидных случаях применяется автоматическое преобразование типов. Используются следующие типы значений:

* ``bool`` - булевый, принимает значения true или false;
* ``bytes`` - последовательность байтов;
* ``int`` - 64-разрядное целое число;
* ``address`` - 64-разрядное беззнаковое целое число;
* ``array`` - массив значений с произвольными типами;
* ``map`` - ассоциативный массив значений с произвольными типами со строковыми ключами;
* ``money`` - целое число типа big integer; значения хранятся в базе данных  без десятичных точек, которые вставляется при выводе в интерфейсе в соответствии с настройками валюты;
* ``float`` - 64-разрядное число с плавающей точкой;
* ``string`` - строка; указываются в двойных или обратных кавычках - "This is a line" или `This is a line`.

Все идентификаторы - имена переменных, функций, контрактов и пр. - регистрозависимы (MyFunc и myFunc - это разные имена). 

Переменные объявляются с помощью ключевого слова **var**, после которого указывается имя или имена переменных и их тип. Переменные определяются и действуют внутри фигурных скобок. При описании переменных им автоматически присваивается значение по умолчанию: для типа *bool* это *false*, для всех числовых типов - нулевые значения, для строк - пустая строка. Примеры объявления переменных: 

.. code:: js

  func myfunc( val int) int {
      var mystr1 mystr2 string, mypar int
      var checked bool
      ...
      if checked {
           var temp int
           ...
      }
  }

Массивы
------------------------------
Язык поддерживает два типа массивов: 

* ``array`` - простой массив с числовым индексом, начинающимся с 0; 
* ``map`` - ассоциативный массив со строковыми ключами.

Присваивание и получение элементов осуществляется указанием индекса в квадратных скобках.

.. code:: js

    var myarr array
    var mymap map
    var s string
    
    myarr[0] = 100
    myarr[1] = "This is a line"
    mymap["value"] = 777
    mymap["param"] = "Parameter"

    s = Sprintf("%v, %v, %v", myarr[0] + mymap["value"], myarr[1], mymap["param"])
    // s = 877, This is a line, Parameter 

Конструкции if и while
------------------------------
Язык описания контрактов содержит стандартные условную конструкцию **if** и конструкцию цикла **while**, которые используются внутри функций, и контрактов. Эти конструкции могут вкладывать друг в друга. 

После ключевого слова должно идти условное выражение. Если условное выражение возвращает число, то оно считается *ложь* при значении 0. Например, *val == 0* эквивалентно *!val*, а *val != 0* тоже самое, что просто *val*. Конструкция **if** может иметь блок **else**, который выполняется если условное выражение **if** ложно. В условном выражении можно использовать операции сравнения: ``<, >, >=, <=, ==, !=``, а также ``||`` (ИЛИ) и ``&&`` (И).

.. code:: js

    if val > 10 || id != $citizen {
      ...
    } else {
      ...
    }

Конструкция **while** предназначена для реализации циклов. Блок **while** выполняется до тех пор, пока его условие истинно. Для прекращения цикла внутри блока используется оператор **break**. Для исполнения блока цикла сначала используется оператор **continue**.

.. code:: js

  while true {
      if i > 100 {
         break
      }
      ...
      if i == 50 {
         continue
      }
      ...
  }

Кроме условных выражений, язык поддерживает стандартные арифметические действия: ``+,-,*,/``
Если в качестве условия вы укажете переменную типа **string** или **bytes**, то условие будет истино, если длина строки (bytes) больше нуля. На пустой строке условие будет ложь.


Функции
------------------------------
Функции языка написания контрактов выполняют операции с данными, полученными в секции ``data`` контракта: чтение значений из базы данных и запись значений в базу данных, преобразование типов значений и установление связи между контрактами. 

Функция определяется с помощью ключевого слова **func**, после которого указывается имя функции, в круглых скобках через запятую передаваемые параметры с указанием типа, после закрывающей скобки - тип возвращаемого значения. Тело функции заключается в фигурные скобки. Если функция не имеет параметров, то круглые скобки можно опустить. Для возврата значения из функции используется ключевое слово ``return``.

.. code:: js

  func myfunc(left int, right int) int {
      return left*right + left - right
  }
  func test int {
      return myfunc(10, 30) + myfunc(20, 50)
  }
  func ooops {
      error "Ooops..."
  }


Функции не возвращают ошибок, так как все проверки на ошибки происходят автоматически.
При генерации ошибки в любой из функции, контракт прекращает свою работу и выводит описание ошибки в специальном окне.
Ошибки при выполнении любой функции обрабатываются автоматически, вызывая остановку выполнения контракта и вывод соответствующего сообщения.

Имеется возможность передавать функции неопределенное количество параметров. Для этого у последнего параметра необходимо вместо типа указать ``...``. В этом случае, последний параметр будет иметь тип *array* и содержать все, начиная с данного параметра, указанные при вызове переменные. Можно передавать переменные любых типов, но вы должны самостоятельно предотвращать конфликты выполнения из-за несовпадений типов.

.. code:: js

  func sum(out string, values ...) {
      var i, res int
      
      while i < Len(values) {
         res = res + values[i]
         i = i + 1
      }
      Println(out, res)
  }

  func main() {
     sum("Sum:", 10, 20, 30, 40)
  }

Рассмотрим ситуацию, когда функция может иметь много параметров, но часто при вызове необходимо указывать только некоторые из них. В этом случае,опциональные параметры можно описывать следующим образом ``func myfunc(name string).Param1(param string).Param2(param2 int) {...}``. При вызове вы можете в любом порядке указывать только некоторые из дополнительных параметров ``myfunc("name").Param2(100)``. В теле функции вы как обычно можете обращаться к этим переменным. Если при вызове расширенный параметр не указан, то он принимает значение по умолчанию, например, пустая строка для строки и ноль для числа. Также, следует заметить, что можно указывать несколько расширенных параметров и использовать ``...`` - ``func DBFind(table string).Where(request string, params ...)`` и вызов ``DBFind("mytable").Where("id > ? and type = ?", myid, 2)``

.. code:: js
 
    func DBFind(table string).Columns(columns string).Where(format string, tail ...)
             .Limit(limit int).Offset(offset int) string  {
       ...
    }
     
Некоторые предопределенные функции позволяют передавать неопределенное количество параметров. Например, *DBUpdate*, *DBInsert*. Имеется возможноть динамически формировать и передавать список параметров. Для этого необходимо записать их в переменную типа *array* и передать её с троеточием. 

.. code:: js
 
    var names, values array
    ...
    DBUpdate("mytable", Join(names, ","), values...)

Предопределенные переменные
------------------------------
При выполнении контракта доступны следующие переменные.

* ``$key_id`` - числовой идентификатор (int64) аккаунта, от которого подписана транзакциюя,
* ``$ecosystem_id`` - идентификатор экосистемы, в которой была создана транзакция, 
* ``$type`` - идентификатор вызываемого контракта. Если, например, контракт вызвал другой контракт, то здесь будет хранится идентификатор оригинального контракта,
* ``$time`` - время указанное в транзакции в формате Unix,
* ``$block`` - номер блока, в котором запечаталась данная транзакция, 
* ``$block_time`` - время указанное в блоке, 
* ``$block_key_id`` - числовой идентифкатор (int64) ноды, которая подписала блок,
* ``$auth_token`` - токен авторизации, который можно использовать в VDE контрактах, например, при вызове контрактов через api c помощью функции ``HTTPRequest``.

.. code:: js

	var pars, heads map
	heads["Authorization"] = "Bearer " + $auth_token
	pars["vde"] = "false"
	ret = HTTPRequest("http://localhost:7079/api/v2/node/mycontract", "POST", heads, pars)

Предопределенные переменные доступны не только в контрактах, но и в полях Permissions, в которых указываются условия доступа к элементам приложений (таблицам, контрактам, страницам и пр.) для составления логических выражений. При этом переменные имеющие отношения к формированию блока (*$time*, *$block* и др.) имеют нулевое значение.

Предопределенная переменной ``$result`` используется при необходимости возвратить значение из вложенного контракта.

Получение значений из таблиц базы данных
==============================

AppParam(app int, name string) string
------------------------------
Функция возвращает значение указанного параметра из параметров приложения (таблица *app_param*). 

* *app* - идентификатор приложения,
* *name* - имя получаемого параметра,

.. code:: js

    Println( AppParam(1, "app_account"))

DBFind(table string) [.Columns(columns string)] [.Where(where string, params ...)] [.WhereId(id int)] [.Order(order string)] [.Limit(limit int)] [.Offset(offset int)] [.Ecosystem(ecosystemid int)] array
------------------------------
Функция возвращает массив *array* из таблицы базы данных *table* в соответствии с указанным запросом. Массив *array* состоит из ассоциативных массивов *map*, содержащих данные из записей таблицы. Для получения массива *map* первого элемента (первой записи запроса) используется функция ``.Row()``. Единичное    значение колонки с именем *column* из первого элемента массива возвращается добавлением функции ``.One(column string)``.

* *table* - имя таблицы,
* *сolumns* - список возвращаемых колонок. Если не указано, то возвратятся все колонки, 
* *Where* - условие поиска. Например, ``.Where("name = 'John'")`` или  ``.Where("name = ?", "John")``,
* *id* - поиск по идентификатору. Достаточно указать значение идентификатора.  Например, ``.WhereId(1)``,
* *order* - поле, по которому нужно отсортировать. По умолчанию, сортируется по *id*,
* *limit* - количество возвращаемых записей. По умолчанию, 25. Максимально возможное количество - 250,
* *offset* - смещение возвращаемых записей,
* *ecosystemid* - идентификатор экосистемы. По умолчанию, берутся данные из таблицы в текущей экосистеме.

.. code:: js

   var i int
   ret = DBFind("contracts").Columns("id,value").Where("id> ? and id < ?", 3, 8).Order("id")
   while i < Len(ret) {
       var vals map
       vals = ret[0]
       Println(vals["value"])
       i = i + 1
   }
   
   var ret string
   ret = DBFind("contracts").Columns("id,value").WhereId(10).One("value")
   if ret != nil { 
   	Println(ret) 
   }

DBRow(table string) [.Columns(columns string)] [.Where(where string, params ...)] [.WhereId(id int)] [.Order(order string)] [.Ecosystem(ecosystemid int)] map
------------------------------
Функция возвращает ассоциативный массив *map*, с данными полученными из таблицы *table* в соответствии с указанным запросом.

* *table* - имя таблицы,
* *сolumns* - список возвращаемых колонок; если не указан, то возвращаются все колонки, 
* *Where* - условие поиска; например, ``.Where("name = 'John'")`` или  ``.Where("name = ?", "John")``,
* *id* - идентификатор возвращаемой строки; например, ``.WhereId(1)``,
* *order* - поле по которому производится сортировка; по умолчанию, сортируется по *id*,
* *ecosystemid* - идентификатор экосистемы; по умолчанию,  id текущей экосистемы.

.. code:: js

   var ret map
   ret = DBRow("contracts").Columns("id,value").Where("id = ?", 1)
   Println(ret)

DBSelectMetrics(metric string, timeInterval string, aggregateFunc string) array
------------------------------
Функция возвращает массив *array* с агрегированными данными для метрики *metric* за указанный интревал времени *timeInterval*, агрегация осуществляется через функцию *aggregateFunc*. Массив *array* состоит из ассоциативных массивов *map*, содержащих данные *key* - ключ, *value* - значение.

Названия метрик:
* *ecosystem_pages* - кол-во страниц экосистемы, *key* - номер экосистемы, *value* - значение,
* *ecosystem_members* - кол-во участников экосистемы, *key* - номер экосистемы, *value* - значение,
* *ecosystem_tx* - кол-во транзакций экосистемы, *key* - номер экосистемы, *value* - значение.
Данные метрики обновляются каждые 30 минут и хранятся в разрезе дня.

* *metric* - название метрики,
* *timeInterval* - интервал вермени, за который требуется получить значения метрик. Например, ``1 day`` или ``30 days``, 
* *aggregateFunc* - функция агрегации. Например, ``max``, ``min`` или ``avg``,

.. code:: js

   var rows array
   rows = DBSelectMetrics("ecosystem_tx", "30 days", "avg")
   
   var i int
   while(i < Len(rows)) {
      var row map
      row = rows[i] // row содержит map, с ключами key и value, где key - номер экосистемы, value - среднее кол-во транзакций за 30 дней
      i = i + 1
   }

EcosysParam(name string) string
------------------------------
Функция возвращает значение указанного параметра из настроек экосистемы (таблица *parameters*). 

* *name* - имя получаемого параметра,
* *num* - порядковый номер параметра.

.. code:: js

    Println( EcosysParam("gov_account"))

GetColumnType(table, column string) string
------------------------------
Функция возвращает тип указанной колонки в указанной таблице. Возвращается наименование внутреннего типа -например, *text,varchar,number,money,double,bytea,json,datetime,double*.

* *table* - имя таблицы,
* *column* - имя колонки.

.. code:: js

    var coltype string
    coltype = GetColumnType("members", "member_name")
	
LangRes(label string, lang string) string
------------------------------
Функция возвращает языковой ресурс с именем label для языка lang, заданного двухсимвольным кодом, например, *en,fr,ru*. Если для указанного языка нет ресурса, то возвращается значение на английском языке. Используется для перевода текста в всплывающих окнах, инициируемых контрактами.

* *label* - имя языкового ресурса,
* *lang* - двухсимвольный код языка.

.. code:: js

    warning LangRes("confirm", $Lang)
    error LangRes("problems", "de")
    
GetBlock(blockID int64) map
------------------------------
Функция возвращает информацию о блоке *blockID*. Информация возвращается в виде ассоциативного массива *map*, содержащего данные:

* *id* - номер блока,
* *time* - время генерации блока в Unix,
* *key_id* - ключ ноды, которая сгенерировала блок.

.. code:: js

   var b map
   b = GetBlock(1)
   Println(b)
	
Изменение значений в таблицах базы данных
==============================

DBInsert(table string, params string, val ...) int
------------------------------
Функция добавляет запись в таблицу *table* и возвращает **id** вставленной записи.

* *tblname* - имя таблицы в базе данных,
* *params* - список через запятую имен колонок, в которые будут записаны перечисленные в **val** значения. 
* *val* - список через запятую значений для перечисленных в **params** столбцов; значения могут иметь строковыми или числовыми.

.. code:: js

    DBInsert("mytable", "name,amount", "John Dow", 100)

DBUpdate(tblname string, id int, params string, val...)
------------------------------
Функция изменяет значения столбцов в таблице в записи с указанным **id**. Если записи с таким идентификатором не существует, то будет выдаваться ошибка.

* *tblname* - имя таблицы в базе данных,
* *id* - идентификатор **id** изменяемой записи,
* *params* - список имен изменяемых колонок; перечисляются через запятую,
* *val* - список значений для указанных столбцов перечисленных в **params**; могут иметь строковый или числовой тип.

.. code:: js

    DBUpdate("mytable", myid, "name,amount", "John Dow", 100)

DBUpdateExt(tblname string, column string, value (int|string), params string, val ...)
------------------------------
Функция обновляет столбцы в записи, у которой колонка имеет заданное значение. Таблица должна иметь индекс по указанной колонке.

* *tblname* - имя таблицы в базе данных,
* *column* - имя колонки, по которой будет идти поиск записи,
* *value* - значение для поиска записи в колонке,
* *params* - список имен колонок, в которые будут записаны значения указанные в **val**; перечисляются через запятую,
* *val* - список значений для записи в колонки перечисленные в  **params**; значения могут быть строковыми или числовыми.

.. code:: js

    DBUpdateExt("mytable", "address", addr, "name,amount", "John Dow", 100)

Операции с массивами
==============================

Join(in array, sep string) string
------------------------------
Функция объединяет элементы массива *in* в строку с указанным разделителем *sep*.

* *in* - имя массива типа *array*, элементы которого необходимо объединить,
* *sep* - строка-разделитель.

.. code:: js

    var val string, myarr array
    myarr[0] = "first"
    myarr[1] = 10
    val = Join(myarr, ",")

JSONToMap(in string) map
------------------------------
Функция конвертирует строку *in* с данными в формате JSON в ассоциативный массив.

* *in* - Строка с данными в JSON формате.

.. code:: js

    var mydata map
    mydata = JSONToMap(`{"name": "John Smith", "company": "Smith's company"}`)

Split(in string, sep string) array
------------------------------
Функция возвращает массив, полученный из элементов строки *in*, при ее разбивании в соответствии с разделителем *sep*.

* *in* - исходная строка,
* *sep* - строка-разделитель.

.. code:: js

    var myarr array
    myarr = Split("first,second,third", ",")

Len(val array) int
------------------------------
Функция возвращает количество элементов в указанном массиве.

* *val* - массив типа *array*.

.. code:: js

    if Len(mylist) == 0 {
      ...
    }

Row(list array) map
------------------------------
Функция возвращает первый ассоциативный массив *map* из массива *list*. Если список *list* пустой, то результат вернет пустой *map*. Используется преимущественно с функцией DBFind, в этом случае параметр *list* не указывается. 

* *list* - массив map, возвращаемый функцией **DBFind**.

.. code:: js

   var ret map
   ret = DBFind("contracts").Columns("id,value").WhereId(10).Row()
   Println(ret)

One(list array, column string) string
------------------------------
Функция возвращает значение ключа *column* из первого ассациативного массива в массиве *list*. Если список *list* пустой, то возвращается nil. Используется преимущественно с функцией DBFind, в этом случае параметр *list* не указывается. 

* *list* - массив map, возвращаемый функцией **DBFind**,
* *column* - имя возвращаемого ключа.

.. code:: js

   var ret string
   ret = DBFind("contracts").Columns("id,value").WhereId(10).One("value")
   if ret != nil {
      Println(ret)
   }

Операции с контрактами и условиями
==============================

CallContract(name string, params map)
------------------------------
Функция вызывает контракт по его имени. В передаваемом массиве должны быть перечислены все параметры, указанные в section *data* контракта. Функция возвращает значение, которое было присвоено переменной **$result** в контракте.

* *name* - имя вызываемого контракта,
* *params* - ассоциативный массив с входными данными для контракта.

.. code:: js

    var par map
    par["Name"] = "My Name"
    CallContract("MyContract", par)

ContractAccess(name string, [name string]) bool
------------------------------
Функция проверяет, совпадает ли имя выполняемого контракта с одним из имен, перечисленных в параметрах. Используется для контроля доступа контрактов к таблицам. Функция прописывается в полях *Permissions* колонок таблицы или в полях *Insert* и *New Column* в разделе *Table permission*.

* *name* - имя контракта.

.. code:: js

    ContractAccess("MyContract")  
    ContractAccess("MyContract","SimpleContract") 
    
ContractConditions(name string, [name string]) bool
------------------------------
Функция вызывает секцию **conditions** контрактов с указанными именами (у контрактов секция *data* должен быть пустой). Если секция *conditions* выполнилась без ошибок, то возвращается *true*, в противном случае "false*. Функция используется в полях *Permissions* для задания прав доступа к соотвествующим операциям с элементами приложений (страницами, таблицами, контрактами и пр), а так же в секции *conditions* контрактов - если в процессе выполнения перечисленный в парараметрах контрактов сгенерировалась ошибка, то родительский контракт также завершится с данной ошибкой.

* *name* - имя контракта.

.. code:: js

    ContractConditions("MainCondition")  

EvalCondition(table string, name string, condfield string) 
------------------------------
Функция берет из таблицы *table* значение поля *condfield* из записи с полем *'name'*, которое равно параметру *name*, и проверяет выполнено ли условие полученное из поля *condfield* или нет. Если условие не выполнено, то генерируется ошибка, с которой и завершается вызывающий контракт.

* *table* - имя таблица,
* *name* - значение для поиска по полю 'name',
* *condfield* - имя поля где хранится условие, которое необходимо будет проверить.

.. code:: js

    EvalCondition(`menu`, $Name, `condition`)  

GetContractById(id int) string
------------------------------
Функция возвращает имя контракта по его идентификатору. Если контракт не найден, то возвращается пустая строка.

* *id* - идентификатор контракта в таблице *contracts*.

.. code:: js

    var id int
    id = GetContractById(`NewBlock`)  

GetContractByName(name string) int
------------------------------
Функция возвращает идентификатор контракта в таблице *contracts* по его имени. Если контракт не найден, то возвращается ноль.

* *name* - идентификатор контракта в таблице *contracts*.

.. code:: js

    var name string
    name = GetContractByName($IdContract)  

ValidateCondition(condition string, ecosystemid int) 
------------------------------
Функция пытается скомпилировать условие, указанное в параметре *condition*. Если в процессе компиляции условия возникнет ошибка, то будет сгенерирована ошибка и вызывающий контракт закончит свою работу. Данная функция предназначена для проверки правильности условий при их изменении.

* *condition* - проверяемое условие,
* *ecosystemid* - идентифкатор экосистемы.

.. code:: js

    ValidateCondition(`ContractAccess("@1MyContract")`, 1)  


Операции с адресами аккаунтов
==============================
    
AddressToId(address string) int
------------------------------
Функция возвращает числовой идентификатор владельца аккаунта по строковому значению адреса аккаунта. Если указан несуществующий адрес, то возвращается 0.

* *address* - адрес аккаунта в формате XXXX-...-XXXX или в виде числа.

.. code:: js

    account = AddressToId($Recipient)
    
IdToAddress(id int) string
------------------------------
Функция возвращает строковый адрес аккаунта по числовому идентификатору его владельца. Если указан несуществующий id, то возвращается 'invalid'.

* *id* - числовой идентификатор.

.. code:: js

    $address = IdToAddress($id)
    
PubToID(hexkey string) int
------------------------------
Функция возвращает числовой идентификатор владельца публичного ключа. При ошибке возвращает ноль.

* *hexkey* - публичный ключ в виде шестнадцатиричной строки

.. code:: js

    var keyId int
    keyId = PubToID("fa5e78.....34abd6")    
    

Операции со значениями переменных
==============================

DecodeBase64(input string) string
------------------------------
Функция раскодирует строку в кодировке base64.

* *input* - входящая строка в кодировке base64.

.. code:: js

    val = DecodeBase64(mybase64)
    
EncodeBase64(input string) string
------------------------------
Функция кодирует строку в кодировку base64 и возвращает строку в закодированном виде.

* *input* - входящая строка.

.. code:: js

    var base64str string
    base64str = EncodeBase64("my text")

Float(val int|string) float
------------------------------
Функция преобразует целое число *int* или *string* в число с плавающей точкой.

* *val* - целое число или строка.

.. code:: js

    val = Float("567.989") + Float(232)

HexToBytes(hexdata string) bytes
------------------------------
Функция преобразует строку с шестнадцатеричной кодировкой в значение  типа *bytes* (последовательность байт).

* *hexdata* - строка, содержащая шестнадцатеричную запись.

.. code:: js

    var val bytes
    val = HexToBytes("34fe4501a4d80094")

Random(min int, max int) int
------------------------------
Функция возвращает случайное число в диапазоне между min и max (min <= result < max). min и max должны быть положительными числами.

* *min* - минимальное значение случайного числа,
* *max* - Случайное значение будет меньше этого числа.

.. code:: js

    i = Random(10,5000)


Int(val string) int
------------------------------
Функция преобразует строковое значение в целое число.

* *val* - строка содержащая число.

.. code:: js

    mystr = "-37763499007332"
    val = Int(mystr)
    

Sha256(val string) string
------------------------------
Функция возвращает хэш **SHA256** от указанной строки.

* *val* - входящая строка, для которой нужно вычислить хэш **Sha256**.

.. code:: js

    var sha string
    sha = Sha256("Test message")

Str(val int|float) string
------------------------------
Функция преобразует числовое значение типа *int* или *float* в строку.

* *val* - целое или число с плавающей точкой.

.. code:: js

    myfloat = 5.678
    val = Str(myfloat)

UpdateLang(name string, trans string)
------------------------------
Функция обновляет языковой ресурс в памяти. Используется в транзакциях, которые меняют языковые ресурсы.

* *name* - имя языкового ресурса,
* *trans* - ресурс с переводами.

.. code:: js

    UpdateLang($Name, $Trans)

Операции со строковыми значениями
==============================

HasPrefix(s string, prefix string) bool
------------------------------
Функция возвращает true, если строка начинается с указанной подстроки *prefix*.

* *s* - проверяема строка,
* *prefix* - проверяемый префикс у данной строки.

.. code:: js

    if HasPrefix($Name, `my`) {
    ...
    }

Contains(s string, substr string) bool
------------------------------
Функция возвращает true, если строка *s* содержит подстроку *substr*.

* *s* - проверяема строка,
* *substr* - подстрока, которая ищется в указанной строке.

.. code:: js

    if Contains($Name, `my`) {
    ...
    }    
 
Replace(s string, old string, new string) string
------------------------------
Функция заменять в строке *s* все вхождения строки *old* на строку *new* и возвращает полученный результат.

* *s* - исходная строка,
* *old* - заменяемая строка,
* *new* - новая строка.

.. code:: js

    s = Replace($Name, `me`, `you`)

Size(val string) int
------------------------------
Функция возвращает количество символов в указанной строке.

* *val* - входящая строка.

.. code:: js

    var len int
    len = Size($Name)

Sprintf(pattern string, val ...) string
------------------------------
Функция формирует строку на основе указанного шаблона и параметров, можно использовать ``%d`` (число), ``%s`` (строка), ``%f`` (float), ``%v`` (для любых типов).

* *pattern* - шаблон для формирования строки.

.. code:: js

    out = Sprintf("%s=%d", mypar, 6448)

Substr(s string, offset int, length int) string
------------------------------
Функция возвращает подстроку от указанной строки начиная со смещения *offset* (cчитается с 0) и длиной *length*. В случае некорректных смещений или длины возвращается пустая строка. Если сумма смещения и *length* больше размера строки, то возвратится подстрока от смещения до конца строки.

* *val* - входящая строка,
* *offset* - начальное смещение подстроки,
* *length* - размер подстроки.

.. code:: js

    var s string
    s = Substr($Name, 1, 10)

Операции с системными параметрами
==============================

SysParamString(name string) string
------------------------------
Функция возвращает значение указанного системного параметра.

* *name* - имя параметра.

.. code:: js

    url = SysParamString(`blockchain_url`)

SysParamInt(name string) int
------------------------------
Функция возвращает значение указанного системного параметра в виде числа.

* *name* - имя параметра.

.. code:: js

    maxcol = SysParam(`max_columns`)

DBUpdateSysParam(name, value, conditions string)
------------------------------
Функция обновляет значение и условие системного параметра. Если значение или условие менять не нужно, то в соответствующем параметре следует указать пустую строку.

* *name* - имя параметра,
* *value* - новое значение параметра,
* *conditions* - новое условие изменения параметра.

.. code:: js

    DBUpdateSysParam(`fuel_rate`, `400000000000`, ``)

Работа с JSON в запросах к PostgreSQL
==============================

В качестве типа колонок вы можете указывать тип **JSON**. В этом случае, если вы хотите обращаться к полям записи, вам следует использовать запись вида **имяколонки->имяполя**. Полученное значение будет записано в колонку с именем **имяколонки.имяполя**. Обращение **имяколонки->имяполя** можно использовать в параметрах *Columns,One,Where* при запросах **DBFind**.

.. code:: js

	var ret map
	var val str
	var list array
	ret = DBFind("mytable").Columns("myname,doc,doc->ind").WhereId($Id).Row()
	val = ret["doc.ind"]
	val = DBFind("mytable").Columns("myname,doc->type").WhereId($Id).One("doc->type")
	list = DBFind("mytable").Columns("myname,doc,doc->ind").Where("doc->ind = ?", "101")
	val = DBFind("mytable").WhereId($Id).One("doc->check")
		

Операции датой/временем в запросах к PostgreSQL
==============================

Функции не дают возможности напрямую отправлять запросы с select, update и т.д., но они позволяют использовать возможности и функции PostgrеSQL при получении значений и описания условий where в выборках. Это относится в том числе и к функциям работающим с датами и временем. Например, необходимо сравнить колонку *date_column* и текущее время. Если *date_column* имеет тип timestamp, то выражение будет следующим ``date_column > now()``, а если *date_column* хранит время в Unix формате в виде числа, то тогда выражение будет ``to_timestamp(date_column) > now()``. 

.. code:: js

    to_timestamp(date_column) > now()
    date_initial < now() - 30 * interval '1 day'

Рассмотрим ситуацию, когда у нас есть значение в формате Unix и необходимо записать его в поле имеющее тип *timestamp*. В этом случае, при перечислении полей, перед именем данной колонки необходимо указать **timestamp**. 

.. code:: js

   DBInsert("mytable", "name,timestamp mytime", "John Dow", 146724678424 )

Если же вы имеете строковое значение времени и вам нужно записать его в поле с типом *timestamp*. В этом случае,  **timestamp** необходимо указать перед самим значением. 

.. code:: js

   DBInsert("mytable", "name,mytime", "John Dow", "timestamp 2017-05-20 00:00:00" )
   var date string
   date = "2017-05-20 00:00:00"
   DBInsert("mytable", "name,mytime", "John Dow", "timestamp " + date )
   DBInsert("mytable", "name,mytime", "John Dow", "timestamp " + $txtime )


Функции для VDE
==============================
Данные функции можно использовать только в контрактах virtual dedicated ecosystems (VDE).

HTTPRequest(url string, method string, heads map, pars map) string
------------------------------
Функция отправляет HTTP запрос на указанный адрес.

* *url* - адрес, на который будет отправлен запрос,
* *method* - метод запроса - GET или POST,
* *heads* - массив данных для формирования заголовка,
* *pars* - параметры.

.. code:: js

	var ret string 
	var pars, heads, json map
	heads["Authorization"] = "Bearer " + $auth_token
	pars["vde"] = "true"
	ret = HTTPRequest("http://localhost:7079/api/v2/content/page/default_page", "POST", heads, pars)
	json = JSONToMap(ret)

HTTPPostJSON(url string, heads map, pars string) string
------------------------------
Функция подобна функции *HTTPRequest*, но отправляет *POST* запрос и параметры передаются одной строкой.

* *url* - адрес, куда будет отправлен запрос,
* *heads* - массив данных для формирования заголовка,
* *pars* - параметр в виде json строки.

.. code:: js

	var ret string 
	var heads, json map
	heads["Authorization"] = "Bearer " + $auth_token
	ret = HTTPPostJSON("http://localhost:7079/api/v2/content/page/default_page", heads, `{"vde":"true"}`)
	json = JSONToMap(ret)

************************************************
Системные контракты
************************************************
Системные контракты создаются по умолчанию при установке платформы в экосистеме №1. Поэтому при вызове их из других экосистем необходимо указывать полное имя, например, ``@1NewContract``.

Список системных контрактов
==============================
NewEcosystem
------------------------------
Контракт создает создает новую экосистему. Для получения идентификатора созданной экосистемы необходимо обратиться к полю *result*, которое возвращается в txstatus. Параметры:
   
* *Name string - имя экосистемы (можно изменить в дальнейшем).

EditEcosystemName
------------------------------
Контракт позволяет изменить имя экосистемы в таблице 1_ecosystems, таблица присутствует только в первой экосистеме
* *SystemID - код экосистемы, имя которой требуется изменить
* *NewName - новое имя экосистемы

MoneyTransfer
------------------------------
Контракт переводит токены платформы с аккаунта текущего пользователя на указанный аккаунт в первой экосистеме. Параметры:

* *Recipient string* - акканут получателя в любом формате - число или ``XXXX-....-XXXX``,
* *Amount    string* - сумма переводимых токенов,
* *Comment   string "optional"* - комментарий.

NewContract
------------------------------
Контракт создает новый контракт в текущей экосистеме. Параметры:

* *Value string* - текст контракта. На верхнем уровне должен быть только один контракт. 
* *Conditions string* - условие изменения контракта.
* *Wallet string "optional"* - идентификатор аккаунта пльзователя, к которому планируется привязать контракт (по умолчанию основателя экосистемы).
* *TokenEcosystem int "optional"* - идентификатор экосистемы в токенах которой будет происходить оплата, если контракт будет активрован.

EditContract
------------------------------
Изменение контракта в текущей экосистеме. Параметры:
      
* *Id int* - идентификатор изменяемого контракта,
* *Value string "optional"* - текст контракта или контрактов,
* *Conditions string "optional"* - права доступа на изменение контракта. 

ActivateContract
------------------------------
Привязка контракта к аккаунту в текущей экосистеме. Привязка возможна с к аккаунту, который был указан при создании контракта. После привязки, с указанного аккаунта будет оплачивать выполнение данного контракта. Параметры:
      
* *Id int* - идентификатор привязываемого контракта.

DeactivateContract
------------------------------
Отвязка  контракта от аккаунта в текущей экосистеме. Отвязка возможна с того с аккаунта, к которому был привязан контракт. После отвязки контракта, его выполнение будут оплачивать вызывающие его пользователи. Параметры:
      
* *Id int* - идентификатор отвязываемого контракта.

NewParameter
------------------------------
Контракт добавляет новый параметр к текущей экосистеме. Параметры:

* *Name string* - имя параметра,
* *Value string* - значение параметра,
* *Conditions string* - права на изменение параметра.

EditParameter
------------------------------
Контракт изменяет существующий параметр в текущей экосистеме. Параметры:

* *Name string* - имя изменяемого параметра,
* *Value string* - новое значение параметра,
* *Conditions string* - новые права на изменение параметра.

NewMenu
------------------------------
Контракт добавляет новое меню к текущей экосистеме. Параметры:

* *Name string* - имя меню,
* *Value string* - текст меню,
* *Title string "optional"* - заголовок меню,
* *Conditions string* - права на изменение меню.

EditMenu
------------------------------
Контракт изменяет существующее меню в текущей экосистеме. Параметры:

* *Id int* - идентификатор изменяемого меню,
* *Value string "optional"* - новай текст меню,
* *Title string "optional"* - заголовок меню,
* *Conditions string "optional"* - новое права на изменение меню.

AppendMenu
------------------------------
Контракт добавляет текст к существующему меню в текущей экосистеме. Параметры:

* *Id int* - идентификатор дополняемого меню,
* *Value string* - добавляемый текст.

NewPage
------------------------------
Контракт добавляет новую страницу в текущей экосистеме. Параметры:

* *Name string* - имя страницы,
* *Value string* - текст страницы,
* *Menu string* - имя меню, привязанного к данной странице,
* *Conditions string* - права на изменение страницы,
* *ValidateCount int "optional"* - кол-во нод для проверки валидности страницы, если параметр не задан, то используется значение из параметра экосистемы *min_page_validate_count*. Значение не может быть меньше *min_page_validate_count* и больше *max_page_validate_count*,
* *ValidateMode int "optional"* - количество проверок страниц. 0 - только при загрузке, 1 - при загрузке и при уходе со страницы.

EditPage
------------------------------
Контракт изменяет существующую страницу в текущей экосистеме. Параметры:

* *Id int* - идентификатор изменяемой страницы,
* *Value string "optional"* - новый текст страницы,
* *Menu string "optional"* - имя нового меню страницы,
* *Conditions string "optional"* - новые права на изменение страницы,
* *ValidateCount int "optional"* - кол-во нод для проверки валидности страницы, если параметр не задан, то используется значение из параметра экосистемы *min_page_validate_count*. Значение не может быть меньше *min_page_validate_count* и больше *max_page_validate_count*.
* *ValidateMode string "optional"* - количество проверок страниц. 0 - только при загрузке, 1 - при загрузке и при уходе со страницы.

AppendPage
------------------------------
Контракт добавляет текст к существующей странице текущей экосистеме. Параметры:

* *Id int* - идентификатор изменяемой страницы,
* *Value string* - добавляемый текст к странице.

NewBlock
------------------------------
Контракт добавляет новый страничный блок в текущей экосистеме. Параметры:

* *Name string* - имя блока,
* *Value string* - текст блока,
* *Conditions string* - права на изменение блока.

EditBlock
------------------------------
Контракт изменяет существующий блок в текущей экосистеме. Параметры:

* *Id int* - идентификатор изменяемого блока,
* *Value string "optional"* - новый текст блока,
* *Conditions string "optional"* - новые права на изменение блока.

NewTable
------------------------------
Контракт добавляет новую таблицу в текущей экосистеме. Параметры:

* *Name string* - имя таблицы (только латинские символы),
* *Columns string* - массив колонок в JSON формате ``[{"name":"...", "type":"...","index": "0", "conditions":"..."},...]``, где

  * *name* - наименование колонки - латинские символы,
  * *type* - тип ``varchar, bytea, number, datetime, money, text, double, character``,
  * *index* - неиндексируемое поле  - "0", создать индекс - "1".
  * *conditions* - права на изменение данных в столбце; если необходимо указать права доступа на чтение, то нужно использовать JSON формат. Например, ``{"update":"ContractConditions(`MainCondition`)", "read":"ContractConditions(`MainCondition`)"}``

* *Permissions string* - права на доступ в JSON формате ``{"insert": "...", "new_column": "...", "update": "..."}``, где

  * *insert* - права на вставку записей,
  * *new_column* - права на добавление колонки,
  * *update* - права на изменение прав.

EditTable
------------------------------
Контракт изменяет права на доступ к таблице в текущей экосистеме. Параметры:

* *Name string* - имя таблицы, 
* *Permissions string* - Разрешения на доступ в JSON формате ``{"insert": "...", "new_column": "...", "update": "..."}``, где

  * *insert* - права на вставку записей,
  * *new_column* - права на добавление колонки,
  * *update* - права на изменение прав.
   
NewColumn
------------------------------
Контракт добавляет новую колонку к таблице в текущей экосистеме. Параметры:

* *TableName string* - имя таблицы,
* *Name* - наименование колонки (тольколатинские символы),
* *type* - тип ``varchar, bytea, number, datetime, money, text, double, character``,
* *Index* - неиндексируемое поле  - "0", создать индекс - "1",
* *Permissions* - права на изменение данных в столбце; если необходимо указать права доступа на чтение, то нужно использовать JSON формат, например, ``{"update":"ContractConditions(`MainCondition`)", "read":"ContractConditions(`MainCondition`)"}``.

EditColumn
------------------------------
Контракт меняет права на изменение колонки в таблице в текущей экосистеме. Параметры:

* *TableName string* - имя таблицы,
* *Name* - имя колонки,
* *Permissions* - права на изменение значений в колонке, если необходимо указать права доступа на чтение, то нужно использовать JSON формат, например,  ``{"update":"ContractConditions(`MainCondition`)", "read":"ContractConditions(`MainCondition`)"}``.

NewLang
------------------------------
Контракт добавляет языковые ресурсы в текущей экосистеме. Права на добавление определяются в параметре *changing_language* в настройках экосистемы. Параметры:

* *Name string* - имя языкового ресурса (только латинские символы). 
* *Trans* - языковые ресурсы в виде строки в JSON формате, где ключ - двухсимвольный код языков, значение - перевод, например: ``{"en": "English text", "ru": "Английский текст"}``.

EditLang
------------------------------
Контракт обновляет языковой ресурс в текущей экосистеме. Права на обновление определяются в параметре *changing_language* в настройках экосистемы. Параметры

* *Name string* - имя языкового ресурса. 
* *Trans* - языковые ресурсы в виде строки в JSON формате, где ключ - двухсимвольный код языков, значение - перевод, например: ``{"en": "English text", "ru": "Английский текст"}``.

NewSign
------------------------------
Контракт создает данные для для контрактов с подписью в текущей экосистеме. Параметры:

* *Name string* - имя контракта, который будет использовать дополнительную подпись. 
* *Value string* - описание параметров в виде JSON строки, где 
    
  * *title* - текст сообщения,
  * *params* - массив параметров, которые показываются пользователю, где **name** - имя поля, **text** - описание параметра.
    
* *Conditions string* - права на изменение записи.

Пример значения *Value*

``{"title": "Would you like to sign?", "params":[{"name": "Receipient", "text": "Account"},{"name": "Amount", "text": "Amount(EGS)"}]}``

EditSign
------------------------------
Контракт обновляет данные для для контрактов с подписью в текущей экосистеме. Параметры:

* *Id int* - идентификатор изменяемой подписи,
* *Value string* - новое значение параметров,
* *Conditions string* - новые права на изменение параметров подписи.

Import 
------------------------------
Контракт импортирует данные из файла *.sim в экосистему. Параметры:

* *Data string* - импортируемые данные, полученные при экспорте приложений в *.sim файл.

NewCron
------------------------------
Контракт добавляет новую задачу в cron для запуска по таймеру. Контракт присутствует только в VDE системах. Параметры:

* *Cron string* - строка, определяющая запуск контракта по таймеру в формате *cron*,
* *Contract string* - имя запускаемого в VDE контракта, контракт не должен содержать параметров в секции ``data``,
* *Limit int* - необязательное поле, в котором можно указать количество запусков (пока не исполняется),
* *Till string* - необязательно поле с временем окончания задачи (пока не учитывается),
* *Conditions string* - права на изменение задачи.

EditCron
------------------------------
Контракт изменяет настройки задачи в cron для запуска по таймеру. Контракт присутствует только в VDE системах. Параметры:

* *Id int* - идентификатор задачи,
* *Cron string* - строка, определяющая запуск контракта по таймеру в формате *cron*; чтобы отключить задачу, нужно не указывать этот параметр или указать пустую строку,
* *Contract string* - имя запускаемого VDE контракта, контракт не должен содержать параметров в секции ``data``,
* *Limit int* - необязательное поле, в котором можно указать количество запусков (пока не исполняется),
* *Till string* - необязательно поле с временем окончания задачи (пока не учитывается),
* *Conditions string* - новые права на изменение задачи.

NewAppParam
------------------------------
Контракт добавляет новый параметр приложения в текущей экосистеме. Параметры:

* *App int* - идентификатор приложения,
* *Name string* - имя параметра,
* *Value string* - значение параметра,
* *Conditions string* - права на изменение параметра.

EditAppParam
------------------------------
Контракт изменяет существующий параметр приложения в текущей экосистеме. Параметры:

* *App int* - идентификатор приложения,
* *Name string* - имя изменяемого параметра,
* *Value string* - новое значение параметра,
* *Conditions string* - новые права на изменение параметра.

NewDelayedContract
------------------------------
Контракт добавляет новое задание в планировщик запуска отложенных контрактов. Планировщик запуска отложенных контрактов запускает необходимые контракты для текущего генерируемого блока. Параметры:

* *Contract string* - название контракта, который требуется запустить,
* *EveryBlock int* - шаг в блоках, через который требуется запускать контракт,
* *Conditions string* - права на изменение задания,
* *BlockID int "optional"* - номер блока в котором требуется запустить контракт, если не указан, то рассчитывается автоматически "текущий номер блока" + $EveryBlock,
* *Limit int "optional"* - лимит кол-ва запусков задания, если лимит не указан, то задание с запуском контракта будет выполняться неограниченное кол-во раз.

EditDelayedContract
------------------------------
Контракт изменяет задание в планировщике запуска отложенных контрактов. Параметры:

* *Id int* - идентификатор задания,
* *Contract string* - название контракта, который требуется запустить,
* *EveryBlock int* - шаг в блоках, через который требуется запускать контракт,
* *Conditions string* - права на изменение задания,
* *BlockID int "optional"* - номер блока в котором требуется запустить контракт, если не указан, то рассчитывается автоматически "текущий номер блока" + $EveryBlock,
* *Limit int "optional"* - лимит кол-ва запусков задания, если лимит не указан, то задание с запуском контракта будет выполняться неограниченное кол-во раз,
* *Deleted int "optional"* - отключение задания, *1* - отключает, *0* - включает.

UUID
------------------------------
Генерирует и возвращает новый UUID 4 типа как строку

UploadBinary
------------------------------
Контракт добавляет/перезаписывает статичный файл в X_binaries. Параметры:

* *Name string* - название статичного файла,
* *Data string* - данные статичного файла в base64 с описанием Mime Type файла, пример: `data:mime/type;base64,...`,
* *AppID int* - идентификатор приложения,
* *MemberID int "optional"* - идентификатор пользователя, по умолчанию 0.

Если MemberID не передан, то статика является системной.


